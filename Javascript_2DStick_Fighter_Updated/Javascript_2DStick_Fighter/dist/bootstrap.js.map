{"version":3,"file":"bootstrap.js","sources":["../src/game/preloader.js","../src/game/saveManager.js","../src/game/eventManager.js","../src/game/gameContext.js","../src/ui/screenManager.js","../src/game/obstacles.js","../src/game/controls.js","../src/game/AnimationPlayer.js","../src/game/animations.js","../src/game/skeleton.js","../src/game/hitSparks.js","../src/game/stickman.js","../src/game/constants.js","../src/game/ai.js","../src/game/powerups.js","../src/bootstrap.js","../src/game/canvasManager.js"],"sourcesContent":["// preloader.js - Asset preloader for Stick Fighter\r\n// Usage: import { preloadAssets } from './preloader.js';\r\n//        preloadAssets(onProgress).then(assets => { ... });\r\n\r\nconst assetManifest = [\r\n  { key: 'stickmanSprite', type: 'image', path: './assets/sprites/stickman.png' },\r\n  { key: 'background',    type: 'image', path: './assets/backgrounds/arena.png' },\r\n  { key: 'hitSound',      type: 'audio', path: './assets/sfx/hit.wav' },\r\n  // Add more assets as needed\r\n];\r\n\r\nexport function preloadAssets(onProgress) {\r\n  const promises = assetManifest.map(asset => {\r\n    return new Promise((resolve, reject) => {\r\n      if (asset.type === 'image') {\r\n        const img = new window.Image();\r\n        img.src = asset.path;\r\n        img.onload = () => resolve({ key: asset.key, data: img });\r\n        img.onerror = reject;\r\n      } else if (asset.type === 'audio') {\r\n        const audio = new window.Audio();\r\n        audio.src = asset.path;\r\n        audio.oncanplaythrough = () => resolve({ key: asset.key, data: audio });\r\n        audio.onerror = reject;\r\n      } else {\r\n        // JSON or other types\r\n        fetch(asset.path)\r\n          .then(res => res.json())\r\n          .then(json => resolve({ key: asset.key, data: json }))\r\n          .catch(reject);\r\n      }\r\n    }).then(result => {\r\n      if (onProgress) onProgress(assetManifest.indexOf(asset) + 1, assetManifest.length);\r\n      return result;\r\n    });\r\n  });\r\n  return Promise.all(promises);\r\n}\r\n","// saveManager.js - Save/load game state to localStorage for Stick Fighter\r\nconst SAVE_KEY = 'stickFighterSave';\r\n\r\nexport function saveGameState(stateObj) {\r\n  try {\r\n    const text = JSON.stringify(stateObj);\r\n    localStorage.setItem(SAVE_KEY, text);\r\n  } catch (e) {\r\n    console.error('Error saving game state:', e);\r\n  }\r\n}\r\n\r\nexport function loadGameState() {\r\n  const raw = localStorage.getItem(SAVE_KEY);\r\n  if (!raw) return null;\r\n  try {\r\n    const parsed = JSON.parse(raw);\r\n    // Validate minimal shape: must have players array\r\n    if (!parsed.players || !Array.isArray(parsed.players)) {\r\n      throw new Error('Invalid save format');\r\n    }\r\n    return parsed;\r\n  } catch (e) {\r\n    console.warn('Corrupt save detected—clearing:', e);\r\n    localStorage.removeItem(SAVE_KEY);\r\n    return null;\r\n  }\r\n}\r\n","// eventManager.js - Modular, extensible event system for 2D Stick Fighter\n// Provides subscribe, unsubscribe, dispatchEvent, and advanced event features\n\nclass EventManager {\n    constructor() {\n        this.listeners = {};\n        this.eventLog = [];\n        this.debugMode = false;\n    }\n\n    subscribe(eventType, callback) {\n        if (typeof callback !== 'function') {\n            this._logError('subscribe: callback must be a function', { eventType, callback });\n            return;\n        }\n        if (!this.listeners[eventType]) {\n            this.listeners[eventType] = [];\n        }\n        this.listeners[eventType].push(callback);\n        if (this.debugMode) this._log(`Subscribed to event: ${eventType}`);\n    }\n\n    unsubscribe(eventType, callback) {\n        if (!this.listeners[eventType]) return;\n        this.listeners[eventType] = this.listeners[eventType].filter(listener => listener !== callback);\n        if (this.debugMode) this._log(`Unsubscribed from event: ${eventType}`);\n    }\n\n    dispatchEvent(eventType, detail) {\n        if (!this.listeners[eventType]) return;\n        this.eventLog.push({ eventType, detail, timestamp: Date.now() });\n        this.listeners[eventType].forEach(listener => {\n            try {\n                listener(detail);\n            } catch (e) {\n                this._logError(`Error in event listener for ${eventType}: ${e.message}`, { eventType, detail, error: e });\n            }\n        });\n        if (this.debugMode) this._log(`Dispatched event: ${eventType}`, detail);\n    }\n\n    once(eventType, callback) {\n        const wrapper = (detail) => {\n            this.unsubscribe(eventType, wrapper);\n            callback(detail);\n        };\n        this.subscribe(eventType, wrapper);\n    }\n\n    getEventLog() {\n        return [...this.eventLog];\n    }\n\n    clearEventLog() {\n        this.eventLog = [];\n    }\n\n    enableDebug() { this.debugMode = true; }\n    disableDebug() { this.debugMode = false; }\n\n    _log(msg, data) {\n        if (data !== undefined) {\n            // eslint-disable-next-line no-console\n            console.log(`[EventManager] ${msg}`, data);\n        } else {\n            // eslint-disable-next-line no-console\n            console.log(`[EventManager] ${msg}`);\n        }\n    }\n\n    _logError(msg, data) {\n        if (data !== undefined) {\n            // eslint-disable-next-line no-console\n            console.error(`[EventManager ERROR] ${msg}`, data);\n        } else {\n            // eslint-disable-next-line no-console\n            console.error(`[EventManager ERROR] ${msg}`);\n        }\n    }\n}\n\n// Export a singleton instance\nexport const eventManager = new EventManager();\n\n// For advanced use: export the class as well\nexport default EventManager;","// gameContext.js - Centralized game state and integration bus\r\n// Provides a shared context for all game modules and systems\r\n\r\nimport { eventManager } from './eventManager.js';\r\n\r\nexport const gameContext = {\r\n  players: [],\r\n  aiControllers: [],\r\n  obstacles: [],\r\n  powerups: [],\r\n  hitSparks: [],\r\n  eventManager,\r\n  diagnostics: {},\r\n  menuState: null, // Current menu state\r\n  // Add more shared state as needed\r\n};\r\n\r\n// Utility to set and broadcast menu state across all modules\r\nexport function setMenuState(state) {\r\n  gameContext.menuState = state;\r\n  eventManager?.dispatchEvent('showMenu', { state });\r\n}\r\n\r\n// Utility to register a system/component in the context\r\nexport function registerSystem(name, ref) {\r\n  gameContext[name] = ref;\r\n  eventManager?.dispatchEvent('systemRegistered', { name, ref });\r\n}\r\n\r\n// Utility to broadcast a game-wide event\r\nexport function broadcastGameEvent(eventName, payload) {\r\n  eventManager?.dispatchEvent(eventName, payload);\r\n}\r\n\r\n// Example: Hook for analytics/diagnostics\r\nexport function logDiagnostic(event, data) {\r\n  if (!gameContext.diagnostics[event]) gameContext.diagnostics[event] = [];\r\n  gameContext.diagnostics[event].push(data);\r\n  eventManager?.dispatchEvent('diagnostic', { event, data });\r\n}\r\n\r\nexport default gameContext;\r\n","// screenManager.js - Centralized screen/menu state manager for Stick Fighter\r\n// Handles transitions and overlays for MENU, SETTINGS, PAUSED, PLAYING, END\r\n\r\nimport { eventManager } from '../game/eventManager.js';\r\nimport { gameContext } from '../game/gameContext.js';\r\n\r\nexport const SCREEN_STATES = {\r\n  MENU: 'MENU',\r\n  SETTINGS: 'SETTINGS_MENU',\r\n  PAUSED: 'PAUSED',\r\n  PLAYING: 'PLAYING',\r\n  END: 'END'\r\n};\r\n\r\nlet currentScreen = SCREEN_STATES.MENU;\r\nconst listeners = [];\r\n\r\nexport function getScreenState() {\r\n  return currentScreen;\r\n}\r\n\r\nexport function setScreenState(state) {\r\n  if (!Object.values(SCREEN_STATES).includes(state)) return;\r\n  currentScreen = state;\r\n  // Sync with gameContext for global state\r\n  if (gameContext) gameContext.menuState = state;\r\n  listeners.forEach(fn => fn(state));\r\n  eventManager?.dispatchEvent('screenStateChanged', { state });\r\n  // Dispatch showMenu for menu overlay integration on relevant states\r\n  if (eventManager && [SCREEN_STATES.MENU, SCREEN_STATES.PAUSED, SCREEN_STATES.SETTINGS, SCREEN_STATES.END].includes(state)) {\r\n    eventManager.dispatchEvent('showMenu', { state });\r\n  }\r\n}\r\n\r\nexport function onScreenStateChange(fn) {\r\n  if (typeof fn === 'function') listeners.push(fn);\r\n}\r\n\r\n// Utility: show/hide overlays and canvas based on state\r\nexport function updateScreenOverlays() {\r\n  const pauseMenu = document.getElementById('pauseMenuTitle');\r\n  const settingsMenu = document.getElementById('settingsMenuTitle');\r\n  const canvas = document.getElementById('gameCanvas');\r\n  if (pauseMenu) pauseMenu.style.display = (currentScreen === SCREEN_STATES.PAUSED) ? 'block' : 'none';\r\n  if (settingsMenu) settingsMenu.style.display = (currentScreen === SCREEN_STATES.SETTINGS) ? 'block' : 'none';\r\n  // Hide canvas for menu/settings/end, show for playing/paused\r\n  if (canvas) {\r\n    if (currentScreen === SCREEN_STATES.PLAYING || currentScreen === SCREEN_STATES.PAUSED) {\r\n      canvas.style.display = 'block';\r\n    } else {\r\n      canvas.style.display = 'none';\r\n    }\r\n  }\r\n}\r\n\r\n// Listen for state changes to update overlays\r\nonScreenStateChange(updateScreenOverlays);\r\n\r\n// Listen for relevant events to update state\r\nif (eventManager) {\r\n  eventManager.subscribe('pause', () => setScreenState(SCREEN_STATES.PAUSED));\r\n  eventManager.subscribe('resume', () => setScreenState(SCREEN_STATES.PLAYING));\r\n  eventManager.subscribe('showMenu', ({ state }) => setScreenState(state || SCREEN_STATES.MENU));\r\n  eventManager.subscribe('gameOver', () => setScreenState(SCREEN_STATES.END));\r\n  eventManager.subscribe('fightStart', () => setScreenState(SCREEN_STATES.PLAYING));\r\n}\r\n","// obstacles.js - Modular, extensible obstacle system for Stick Fighter\n// Author: Modularized & enhanced from original monolithic code\n\nimport { eventManager } from './eventManager.js';\nimport { getScreenState } from '../ui/screenManager.js';\n\n/**\n * Represents a static rectangular obstacle (platform, wall, etc).\n * @class\n */\nexport class Obstacle {\n  /**\n   * @param {number} x - X position (top-left)\n   * @param {number} y - Y position (top-left)\n   * @param {number} width - Width of the obstacle\n   * @param {number} height - Height of the obstacle\n   * @param {string} [color=\"#8D6E63\"] - Fill color\n   * @param {object} [options] - Extensibility for future types\n   */\n  constructor(x, y, width, height, color = '#8D6E63', options = {}) {\n    try {\n      if (typeof x !== 'number' || typeof y !== 'number' || typeof width !== 'number' || typeof height !== 'number') {\n        throw new TypeError('Obstacle: x, y, width, and height must be numbers');\n      }\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n      this.color = color;\n      this.type = options.type || 'static';\n      this.options = options;\n      this.id = options.id || `obstacle_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;\n      this.debug = options.debug || false;\n      this.retryCount = 0;\n      this.maxRetries = options.maxRetries || 2;\n    } catch (err) {\n      this.handleError(err, 'constructor');\n    }\n  }\n\n  /**\n   * Draws the obstacle on the provided canvas context.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  draw(ctx) {\n    let attempts = 0;\n    while (attempts <= this.maxRetries) {\n      try {\n        if (!ctx) throw new Error('Obstacle.draw: ctx is required');\n        ctx.save();\n        ctx.fillStyle = this.color;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        ctx.strokeStyle = '#5D4037';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(this.x, this.y, this.width, this.height);\n        if (this.debug) {\n          ctx.strokeStyle = 'red';\n          ctx.setLineDash([4, 2]);\n          ctx.strokeRect(this.x, this.y, this.width, this.height);\n          ctx.setLineDash([]);\n        }\n        ctx.restore();\n        break;\n      } catch (err) {\n        this.handleError(err, 'draw');\n        attempts++;\n        if (attempts > this.maxRetries) break;\n      }\n    }\n  }\n\n  /**\n   * Returns an AABB for collision checks.\n   */\n  getAABB() {\n    return { x: this.x, y: this.y, width: this.width, height: this.height };\n  }\n\n  /**\n   * Checks if a point is inside this obstacle.\n   * @param {number} px\n   * @param {number} py\n   * @returns {boolean}\n   */\n  containsPoint(px, py) {\n    return px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height;\n  }\n\n  /**\n   * Checks if this obstacle overlaps with another AABB.\n   * @param {object} rect - {x, y, width, height}\n   * @returns {boolean}\n   */\n  overlaps(rect) {\n    return rectsOverlap(this.getAABB(), rect);\n  }\n\n  /**\n   * Allows dynamic color change (e.g., for hit feedback).\n   * @param {string} color\n   */\n  setColor(color) {\n    try {\n      if (typeof color !== 'string') throw new TypeError('Obstacle.setColor: color must be a string');\n      this.color = color;\n    } catch (err) {\n      this.handleError(err, 'setColor');\n    }\n  }\n\n  /**\n   * Allows moving the obstacle (for future moving platforms).\n   * @param {number} dx\n   * @param {number} dy\n   */\n  move(dx, dy) {\n    try {\n      if (typeof dx !== 'number' || typeof dy !== 'number') throw new TypeError('Obstacle.move: dx and dy must be numbers');\n      this.x += dx;\n      this.y += dy;\n    } catch (err) {\n      this.handleError(err, 'move');\n    }\n  }\n\n  /**\n   * Returns a shallow clone of this obstacle.\n   */\n  clone() {\n    return new Obstacle(this.x, this.y, this.width, this.height, this.color, { ...this.options, id: undefined });\n  }\n\n  /**\n   * Returns a debug string for diagnostics.\n   */\n  toString() {\n    return `Obstacle(${this.x},${this.y},${this.width},${this.height},${this.color},id=${this.id})`;\n  }\n\n  /**\n   * Returns a detailed description of this obstacle for AI, UI, or debugging.\n   * @returns {object}\n   */\n  describe() {\n    return {\n      id: this.id,\n      type: this.type,\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      color: this.color,\n      options: { ...this.options },\n      area: this.width * this.height,\n      aspectRatio: this.width / (this.height || 1),\n      isWide: this.width > this.height,\n      isTall: this.height > this.width,\n      isSquare: Math.abs(this.width - this.height) < 2,\n      // Useful for stickman AI:\n      top: this.y,\n      bottom: this.y + this.height,\n      left: this.x,\n      right: this.x + this.width,\n      center: { x: this.x + this.width / 2, y: this.y + this.height / 2 },\n      debug: this.debug,\n      canClimb: !!this.options.canClimb,\n      canDestroy: !!this.options.canDestroy,\n      canJumpOver: !!this.options.canJumpOver,\n      // Add more as needed for AI/UX\n    };\n  }\n\n  handleError(err, method) {\n    if (!this.errorLog) this.errorLog = [];\n    const errorMsg = `[Obstacle:${this.id}] Error in ${method}: ${err.message}`;\n    this.errorLog.push({ time: Date.now(), method, error: err });\n    if (this.debug) {\n      // Optionally, dispatch error event for diagnostics\n      eventManager?.dispatchEvent('obstacleError', { obstacle: this, method, error: err });\n      // Log to console for devs\n      console.error(errorMsg, err);\n    }\n  }\n}\n\n/**\n * Array to hold all obstacles in the game.\n */\nexport const obstacles = [];\n\n/**\n * Adds an obstacle to the game and dispatches an event.\n * @param {Obstacle} obstacle\n */\nexport function addObstacle(obstacle) {\n  let attempts = 0;\n  while (attempts <= (obstacle?.maxRetries || 2)) {\n    try {\n      if (!(obstacle instanceof Obstacle)) throw new TypeError('addObstacle: argument must be an Obstacle');\n      obstacles.push(obstacle);\n      eventManager.dispatchEvent('obstacleAdded', { obstacle });\n      break;\n    } catch (err) {\n      obstacle?.handleError?.(err, 'addObstacle');\n      attempts++;\n      if (attempts > (obstacle?.maxRetries || 2)) break;\n    }\n  }\n}\n\n// --- Obstacle Destroyed Event System ---\nconst obstacleDestroyedListeners = [];\n\n/**\n * Register a callback to be invoked when an obstacle is destroyed.\n * @param {function} listener - Function to call with the destroyed obstacle as argument\n */\nexport function onObstacleDestroyed(listener) {\n  if (typeof listener === 'function') {\n    obstacleDestroyedListeners.push(listener);\n  }\n}\n\n/**\n * Removes an obstacle by id.\n * @param {string} id\n */\nexport function removeObstacleById(id) {\n  let attempts = 0;\n  while (attempts <= 2) {\n    try {\n      const idx = obstacles.findIndex(o => o.id === id);\n      if (idx !== -1) {\n        const [removed] = obstacles.splice(idx, 1);\n        eventManager.dispatchEvent('obstacleRemoved', { obstacle: removed });\n        // Notify listeners\n        for (const cb of obstacleDestroyedListeners) {\n          try { cb(removed); } catch (e) { console.warn('[obstacles] ObstacleDestroyed listener error:', e); }\n        }\n        return removed;\n      }\n      return null;\n    } catch (err) {\n      attempts++;\n      eventManager?.dispatchEvent('obstacleError', { method: 'removeObstacleById', error: err });\n      console.error(`[Obstacle] Error in removeObstacleById: ${err.message}`, err);\n      if (attempts > 2) break;\n    }\n  }\n  return null;\n}\n\n/**\n * Clears all obstacles.\n */\nexport function clearObstacles() {\n  try {\n    obstacles.length = 0;\n    eventManager.dispatchEvent('obstaclesCleared');\n  } catch (err) {\n    eventManager?.dispatchEvent('obstacleError', { method: 'clearObstacles', error: err });\n    console.error(`[Obstacle] Error in clearObstacles: ${err.message}`, err);\n  }\n}\n\n/**\n * Checks for AABB collision between a rect and any obstacle.\n * @param {object} rect - {x, y, width, height}\n * @returns {Obstacle|null}\n */\nexport function checkObstacleCollision(rect) {\n  for (const obstacle of obstacles) {\n    if (rectsOverlap(rect, obstacle.getAABB())) {\n      return obstacle;\n    }\n  }\n  return null;\n}\n\n/**\n * Utility: Checks if two rectangles overlap (AABB).\n */\nexport function rectsOverlap(r1, r2) {\n  return (\n    r1.x < r2.x + r2.width &&\n    r1.x + r1.width > r2.x &&\n    r1.y < r2.y + r2.height &&\n    r1.y + r1.height > r2.y\n  );\n}\n\n/**\n * Debug: Draw all obstacles with debug info.\n * @param {CanvasRenderingContext2D} ctx\n */\nexport function drawAllObstacles(ctx) {\n  for (const obstacle of obstacles) {\n    obstacle.draw(ctx);\n  }\n}\n\n/**\n * Finds the first obstacle at a given point.\n * @param {number} x\n * @param {number} y\n * @returns {Obstacle|null}\n */\nexport function getObstacleAtPoint(x, y) {\n  return obstacles.find(o => o.containsPoint(x, y)) || null;\n}\n\n/**\n * Returns all obstacles overlapping a given rect.\n * @param {object} rect - {x, y, width, height}\n * @returns {Obstacle[]}\n */\nexport function getObstaclesInRect(rect) {\n  return obstacles.filter(o => o.overlaps(rect));\n}\n\n/**\n * Returns the obstacle with the given id.\n * @param {string} id\n * @returns {Obstacle|null}\n */\nexport function getObstacleById(id) {\n  return obstacles.find(o => o.id === id) || null;\n}\n\n/**\n * Replace all obstacles with a new set (for level loading).\n * @param {Obstacle[]} newObstacles\n */\nexport function setObstacles(newObstacles) {\n  try {\n    clearObstacles();\n    for (const o of newObstacles) obstacles.push(o);\n    eventManager.dispatchEvent('obstaclesSet', { obstacles });\n  } catch (err) {\n    eventManager?.dispatchEvent('obstacleError', { method: 'setObstacles', error: err });\n    console.error(`[Obstacle] Error in setObstacles: ${err.message}`, err);\n  }\n}\n\n/**\n * Toggle debug mode for all obstacles.\n * @param {boolean} debug\n */\nexport function setObstaclesDebug(debug) {\n  for (const o of obstacles) o.debug = debug;\n}\n\n/**\n * Serialize all obstacles to a plain object array (for saving).\n * @returns {object[]}\n */\nexport function serializeObstacles() {\n  return obstacles.map(o => ({ x: o.x, y: o.y, width: o.width, height: o.height, color: o.color, type: o.type, id: o.id }));\n}\n\n/**\n * Load obstacles from a plain object array (for loading).\n * @param {object[]} arr\n */\nexport function loadObstaclesFromArray(arr) {\n  setObstacles(arr.map(obj => new Obstacle(obj.x, obj.y, obj.width, obj.height, obj.color, { type: obj.type, id: obj.id })));\n}\n\n/**\n * Returns a description object for every obstacle (for AI, UI, etc).\n * @returns {object[]}\n */\nexport function describeAllObstacles() {\n  return obstacles.map(o => o.describe());\n}\n\n// Extensibility: Future obstacle types (moving, damaging, destructible) can extend Obstacle.\n// Example:\n// export class MovingObstacle extends Obstacle { ... }\n\n// Diagnostics: Hook into eventManager for obstacle lifecycle events as needed.\n\n// --- Integration: Register obstacle-related events and hooks ---\n// Example: Listen for obstacle events for analytics, debugging, or UI feedback\n\neventManager?.subscribe?.('obstacleAdded', ({ obstacle }) => {\n  // Optionally log or update UI\n  if (obstacle.debug) console.log('[Obstacle] Added:', obstacle.toString());\n});\neventManager?.subscribe?.('obstacleRemoved', ({ obstacle }) => {\n  if (obstacle?.debug) console.log('[Obstacle] Removed:', obstacle?.toString?.());\n});\neventManager?.subscribe?.('obstaclesCleared', () => {\n  console.log('[Obstacle] All obstacles cleared');\n});\neventManager?.subscribe?.('obstaclesSet', ({ obstacles }) => {\n  console.log(`[Obstacle] Obstacles set (${obstacles.length})`);\n});\neventManager?.subscribe?.('obstacleError', ({ obstacle, method, error }) => {\n  console.error(`[Obstacle] Error in ${method}:`, error, obstacle);\n});\n\n// --- Integration with game loop and rendering ---\n// Example: Use drawAllObstacles in the main render function\n// In your main game loop or render function:\n// drawAllObstacles(ctx);\n\n/**\n * Update or draw all obstacles; called in the game loop.\n * @param {number} delta\n * @param {{ctx: CanvasRenderingContext2D}} context\n */\nexport function updateAllObstacles(delta, context) {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  const ctx = context?.ctx || (typeof document !== 'undefined' ? document.getElementById('gameCanvas')?.getContext('2d') : null);\n  if (!ctx) return;\n  // Draw static obstacles\n  drawAllObstacles(ctx);\n}\n\n// --- Integration with controls and gameplay logic ---\n// Example: Use checkObstacleCollision in player movement/collision logic\n// if (checkObstacleCollision(playerRect)) { ... }\n\n// --- Example: Add default obstacles at game start or level load ---\n// setObstacles([\n//   new Obstacle(200, 350, 120, 40),\n//   new Obstacle(480, 340, 120, 60)\n// ]);\n\n// Export all obstacle-related functions as a module default for Rollup compatibility\nexport default {\n  Obstacle,\n  obstacles,\n  addObstacle,\n  onObstacleDestroyed,\n  removeObstacleById,\n  clearObstacles,\n  checkObstacleCollision,\n  rectsOverlap,\n  drawAllObstacles,\n  getObstacleAtPoint,\n  getObstaclesInRect,\n  getObstacleById,\n  setObstacles,\n  setObstaclesDebug,\n  serializeObstacles,\n  loadObstaclesFromArray,\n  describeAllObstacles,\n  updateAllObstacles\n};","// controls.js - Modular input/controls system for 2D Stick Fighter\n// Handles keyboard (and future mouse/gamepad) input, supports remapping, event-driven, and debug integration\n\nimport { eventManager } from './eventManager.js';\nimport { obstacles, checkObstacleCollision } from './obstacles.js';\nimport { getScreenState } from '../ui/screenManager.js';\n\n// Internal state\nconst keyState = {};\nconst listeners = [];\nlet debugMode = false;\nlet keyMap = {};\n\n// Default key bindings for two players\n/**\n * @readonly\n * @type {Readonly<{player1: Object, player2: Object}>}\n */\nconst defaultBindings = Object.freeze({\n    player1: Object.freeze({\n        left: 'KeyA', right: 'KeyD', jump: 'KeyW', punch: 'KeyF', kick: 'KeyG', guard: 'ShiftLeft',\n        slam: 'KeyS', airDodge: 'KeyC', parry: 'KeyV', run: 'KeyQ', turn: 'KeyR'\n    }),\n    player2: Object.freeze({\n        left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', punch: 'KeyK', kick: 'KeyL', guard: 'ShiftRight',\n        slam: 'ArrowDown', airDodge: 'KeyM', parry: 'KeyN', run: 'KeyU', turn: 'KeyP'\n    })\n});\n\n/**\n * Set custom key bindings, merged with defaults.\n * @param {Object} bindings\n */\nfunction setKeyBindings(bindings) {\n    keyMap = { player1: { ...defaultBindings.player1, ...(bindings?.player1 || {}) }, player2: { ...defaultBindings.player2, ...(bindings?.player2 || {}) } };\n}\n\n/**\n * Get a copy of the current key bindings.\n * @returns {Object}\n */\nfunction getKeyBindings() {\n    return { player1: { ...keyMap.player1 }, player2: { ...keyMap.player2 } };\n}\n\n/**\n * Check if a key is currently pressed.\n * @param {string} code\n * @returns {boolean}\n */\nfunction isKeyPressed(code) {\n    return !!keyState[code];\n}\n\n/**\n * Subscribe to input events.\n * @param {Function} callback\n */\nfunction subscribeInput(callback) {\n    if (typeof callback === 'function') listeners.push(callback);\n}\n\n/**\n * Unsubscribe from input events.\n * @param {Function} callback\n */\nfunction unsubscribeInput(callback) {\n    const idx = listeners.indexOf(callback);\n    if (idx !== -1) listeners.splice(idx, 1);\n}\n\nfunction enableDebug() { debugMode = true; }\nfunction disableDebug() { debugMode = false; }\n\n// --- Settings and Utility Extensions ---\nlet settings = {\n    allowRemap: true,\n    allowMultipleKeys: false, // If true, allow multiple keys per action\n    inputDebounceMs: 0, // Debounce time for rapid key events\n    suppressRepeat: true // Ignore repeated keydown events\n};\nlet lastInputTimestamps = {};\n\nfunction setControlsSettings(newSettings) {\n    settings = { ...settings, ...newSettings };\n}\n\nfunction getControlsSettings() {\n    return { ...settings };\n}\n\n// --- Enhanced Event Management, Debugging, and Error Handling ---\n\n// Allow custom error handler for input system\nlet onInputError = (err, context) => { if (debugMode) console.error('[Controls Error]', err, context); };\n\nfunction setInputErrorHandler(handler) {\n    if (typeof handler === 'function') onInputError = handler;\n}\n\n// Allow custom debug event hooks\nlet debugHooks = {\n    onInput: null, // (eventType, payload) => void\n    onRemap: null, // (player, action, oldKey, newKey) => void\n    onRecording: null, // (eventType, payload) => void\n    onPlayback: null // (eventType, payload) => void\n};\n\nfunction setDebugHooks(hooks) {\n    debugHooks = { ...debugHooks, ...hooks };\n}\n\nfunction emitDebugEvent(eventType, payload) {\n    if (debugHooks && typeof debugHooks.onInput === 'function') {\n        try { debugHooks.onInput(eventType, payload); } catch (e) { if (debugMode) console.warn('Debug hook error', e); }\n    }\n    eventManager.dispatchEvent('controlsDebug', { eventType, payload });\n}\n\n// Wrap remapKey for debug and event\nfunction remapKey(player, action, newKey) {\n    if (!settings.allowRemap) return false;\n    if (!keyMap[player]) keyMap[player] = {};\n    const oldKey = keyMap[player][action];\n    keyMap[player][action] = newKey;\n    emitDebugEvent('remap', { player, action, oldKey, newKey });\n    if (typeof debugHooks.onRemap === 'function') {\n        try { debugHooks.onRemap(player, action, oldKey, newKey); } catch (e) { if (debugMode) console.warn('Remap debug hook error', e); }\n    }\n    return true;\n}\n\nfunction getPressedActions(player) {\n    const bindings = keyMap[player] || {};\n    // Use Array.prototype.reduce for performance\n    return Object.entries(bindings).reduce((acc, [action, code]) => {\n        if (keyState[code]) acc.push(action);\n        return acc;\n    }, []);\n}\n\n// --- Utility: Get action for a given key code (reverse lookup) ---\nfunction getActionForKey(player, code) {\n    const bindings = keyMap[player] || {};\n    // Use Object.entries for clarity and performance\n    for (const [action, key] of Object.entries(bindings)) {\n        if (key === code) return action;\n    }\n    return null;\n}\nfunction getKeyForAction(player, action) {\n    return (keyMap[player] && keyMap[player][action]) || null;\n}\n\n// --- Advanced Utility & Features ---\nlet inputHistory = [];\nlet inputHistoryLimit = 100;\nlet inputRecording = false;\nlet inputPlayback = false;\nlet playbackIndex = 0;\nlet playbackData = [];\n\nfunction startInputRecording() {\n    inputHistory = [];\n    inputRecording = true;\n}\n\nfunction stopInputRecording() {\n    inputRecording = false;\n}\n\nfunction getInputHistory() {\n    return [...inputHistory];\n}\n\nfunction setInputHistoryLimit(limit) {\n    inputHistoryLimit = limit;\n}\n\nfunction playInputHistory(history) {\n    if (!Array.isArray(history)) return;\n    playbackData = [...history];\n    playbackIndex = 0;\n    inputPlayback = true;\n    // Optionally, disable real input during playback\n}\n\nfunction stopInputPlayback() {\n    inputPlayback = false;\n    playbackIndex = 0;\n    playbackData = [];\n}\n\nfunction isInputRecording() { return inputRecording; }\nfunction isInputPlayback() { return inputPlayback; }\n\n// --- Combo System ---\nlet comboState = {\n    active: false,\n    sequence: [], // Array of { code, isDown, timestamp }\n    lastInputTime: 0,\n    comboWindow: 350, // ms between presses\n    minComboLength: 2,\n    maxComboLength: 6,\n    onCombo: null // callback(comboSequence)\n};\n\nfunction setComboSettings(settings) {\n    comboState = { ...comboState, ...settings };\n}\n\nfunction getComboSettings() {\n    return { ...comboState };\n}\n\nfunction setComboCallback(cb) {\n    comboState.onCombo = cb;\n}\n\nfunction clearCombo() {\n    comboState.active = false;\n    comboState.sequence = [];\n    comboState.lastInputTime = 0;\n}\n\nfunction _checkComboTimeout(now) {\n    if (comboState.sequence.length > 0 && now - comboState.lastInputTime > comboState.comboWindow) {\n        clearCombo();\n    }\n}\n\nfunction _registerComboInput(code, isDown, timestamp) {\n    if (!isDown) return;\n    const now = timestamp ?? Date.now();\n    _checkComboTimeout(now);\n    if (!comboState.active) comboState.active = true;\n    comboState.sequence.push({ code, isDown, timestamp: now });\n    comboState.lastInputTime = now;\n    // Limit combo length\n    if (comboState.sequence.length > comboState.maxComboLength) {\n        comboState.sequence.shift();\n    }\n    // Check for valid combo\n    if (comboState.sequence.length >= comboState.minComboLength) {\n        // Fire combo callback if set\n        if (typeof comboState.onCombo === 'function') {\n            try { comboState.onCombo([...comboState.sequence]); } catch (e) { if (debugMode) console.warn('Combo callback error', e); }\n        }\n        emitDebugEvent('combo', { sequence: [...comboState.sequence] });\n        fireComboPerformed('player1', [...comboState.sequence]);\n        clearCombo();\n    }\n}\n\n// --- Combo Performed Event System ---\nconst comboPerformedListeners = [];\n\n/**\n * Register a callback to be invoked when a combo is performed.\n * @param {function} listener - Function to call with combo details: ({ player, comboSequence, timestamp })\n */\nexport function onComboPerformed(listener) {\n  if (typeof listener === 'function') {\n    comboPerformedListeners.push(listener);\n  }\n}\n\n// Internal: Call this when a combo is detected in your combo system\nfunction fireComboPerformed(player, comboSequence) {\n  const detail = { player, comboSequence, timestamp: Date.now() };\n  for (const cb of comboPerformedListeners) {\n    try { cb(detail); } catch (e) { if (typeof window !== 'undefined' && window.DEBUG_MODE) console.warn('[controls] ComboPerformed listener error:', e); }\n  }\n  // Optionally, dispatch to eventManager for global eventing\n  if (typeof eventManager?.dispatchEvent === 'function') {\n    eventManager.dispatchEvent('comboPerformed', detail);\n  }\n}\n\n// Enhanced error handling in input event\nfunction shouldDebounceInput(e, isDown) {\n    if (settings.suppressRepeat && isDown && e.repeat) return true;\n    if (settings.inputDebounceMs > 0) {\n        const now = Date.now();\n        if (lastInputTimestamps[e.code] && now - lastInputTimestamps[e.code] < settings.inputDebounceMs) return true;\n        lastInputTimestamps[e.code] = now;\n    }\n    return false;\n}\n\nfunction processDebugHooks(e, isDown) {\n    emitDebugEvent('input', { code: e.code, isDown, event: e });\n    if (debugMode) console.log(`[Controls] ${isDown ? 'Down' : 'Up'}: ${e.code}`);\n}\n\nfunction processInputHistory(e, isDown) {\n    if (inputRecording) {\n        inputHistory.push({ code: e.code, isDown, timestamp: Date.now() });\n        if (inputHistory.length > inputHistoryLimit) inputHistory.shift();\n        if (typeof debugHooks.onRecording === 'function') {\n            try { debugHooks.onRecording('record', { code: e.code, isDown }); } catch (e) { if (debugMode) console.warn('Recording debug hook error', e); }\n        }\n    }\n}\n\nfunction processComboSystem(e, isDown) {\n    _registerComboInput(e.code, isDown, Date.now());\n}\n\nfunction notifyListeners(e, isDown) {\n    listeners.forEach(cb => {\n        try { cb(e.code, isDown, e); } catch (err) { onInputError(err, { code: e.code, isDown, event: e }); }\n    });\n}\n\nfunction handleKeyEvent(e, isDown) {\n    try {\n        if (shouldDebounceInput(e, isDown)) return;\n        keyState[e.code] = isDown;\n        eventManager.dispatchEvent('input', { code: e.code, isDown, event: e });\n        processDebugHooks(e, isDown);\n        notifyListeners(e, isDown);\n        processInputHistory(e, isDown);\n        processComboSystem(e, isDown);\n    } catch (err) {\n        onInputError(err, { code: e.code, isDown, event: e });\n    }\n}\n\nfunction handleKeyDown(e) {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  handleKeyEvent(e, true);\n}\n\nfunction handleKeyUp(e) {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  handleKeyEvent(e, false);\n}\n\n// Enhanced input playback tick with debug and error handling\nfunction tickInputPlayback() {\n    if (!inputPlayback || playbackIndex >= playbackData.length) return;\n    const entry = playbackData[playbackIndex];\n    try {\n        if (entry) {\n            keyState[entry.code] = entry.isDown;\n            eventManager.dispatchEvent('input', { code: entry.code, isDown: entry.isDown, event: null, playback: true });\n            emitDebugEvent('playback', { code: entry.code, isDown: entry.isDown });\n            listeners.forEach(cb => {\n                try { cb(entry.code, entry.isDown, null); } catch (err) { onInputError(err, { code: entry.code, isDown: entry.isDown, playback: true }); }\n            });\n            if (typeof debugHooks.onPlayback === 'function') {\n                try { debugHooks.onPlayback('playback', { code: entry.code, isDown: entry.isDown }); } catch (e) { if (debugMode) console.warn('Playback debug hook error', e); }\n            }\n        }\n        playbackIndex++;\n        if (playbackIndex >= playbackData.length) stopInputPlayback();\n    } catch (err) {\n        onInputError(err, { code: entry?.code, isDown: entry?.isDown, playback: true });\n    }\n}\n\n// Example utility: Expose obstacle info to controls for context-aware input (e.g., jump if obstacle ahead)\nexport function getNearbyObstacleInfo(playerRect, range = 30) {\n  // Returns the first obstacle within range in front of the player\n  const facingRight = playerRect.facingRight !== false;\n  const probeRect = {\n    x: facingRight ? playerRect.x + playerRect.width : playerRect.x - range,\n    y: playerRect.y,\n    width: range,\n    height: playerRect.height\n  };\n  const obs = obstacles.find(o => checkObstacleCollision(probeRect));\n  return obs ? obs.describe() : null;\n}\n\n// --- Utility: clear all input state ---\nfunction clearInputState() {\n    Object.keys(keyState).forEach(k => { keyState[k] = false; });\n}\n\n// Attach global listeners (idempotent)\nif (typeof window !== 'undefined' && !window._stickfighterControlsAttached) {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    window._stickfighterControlsAttached = true;\n}\n\n// --- Integration: Listen for menu reset events to reset controls ---\nif (eventManager && typeof eventManager.subscribe === 'function') {\n    eventManager.subscribe('menuMainMenu', () => {\n        resetKeyBindings();\n    });\n    eventManager.subscribe('resetKeyBindings', () => {\n        resetKeyBindings();\n    });\n}\n\nfunction resetKeyBindings() {\n    keyMap = { player1: { ...defaultBindings.player1 }, player2: { ...defaultBindings.player2 } };\n    eventManager.dispatchEvent('keyBindingsChanged', { bindings: getKeyBindings() });\n}\n\n// Initialize keyMap with default bindings on module load\nsetKeyBindings(defaultBindings);\n\n// Notify external modules of binding changes\n/**\n * Subscribe to changes in key bindings.\n * @param {function(Object)} callback - receives updated bindings object\n */\nexport function onControlsChanged(callback) {\n  if (typeof callback === 'function') {\n    eventManager.subscribe('keyBindingsChanged', ({ bindings }) => callback(bindings));\n  }\n}\n\n// Alias for resetting to defaults (used by UI integration)\nexport const resetToDefaults = resetKeyBindings;\n\n// Stub for remap UI trigger (used by UI integration)\nexport function enableRemapUI() {\n  // Placeholder: show remapping UI via event\n  eventManager.dispatchEvent('showControlsRemap', {});\n}\n\n/**\n * Attach global listeners for input (idempotent)\n */\nexport function initControls() {\n  if (typeof window !== 'undefined' && !window._stickfighterControlsAttached) {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    window._stickfighterControlsAttached = true;\n  }\n}\n\n// Add JSDoc to all exports for better integration\nexport {\n    setKeyBindings,\n    getKeyBindings,\n    isKeyPressed,\n    subscribeInput,\n    unsubscribeInput,\n    enableDebug,\n    disableDebug,\n    keyState,\n    defaultBindings,\n    setControlsSettings,\n    getControlsSettings,\n    remapKey,\n    getActionForKey,\n    getKeyForAction,\n    resetKeyBindings,\n    getPressedActions,\n    startInputRecording,\n    stopInputRecording,\n    getInputHistory,\n    setInputHistoryLimit,\n    playInputHistory,\n    stopInputPlayback,\n    isInputRecording,\n    isInputPlayback,\n    tickInputPlayback,\n    clearInputState,\n    setInputErrorHandler,\n    setDebugHooks,\n    emitDebugEvent,\n    setComboSettings,\n    getComboSettings,\n    setComboCallback,\n    clearCombo\n};","// Animation data structures and player for 2D Stick Fighter\r\n\r\n/**\r\n * A keyframe within a track.\r\n * @typedef {Object} Keyframe\r\n * @property {number} time - Time (ms) within the clip.\r\n * @property {number} value - Value at this keyframe (e.g. rotation in radians).\r\n * @property {string} [easing] - Easing function name (e.g. 'linear').\r\n */\r\n\r\n/**\r\n * A track animates a single property on a skeleton or character.\r\n */\r\nexport class Track {\r\n  /**\r\n   * @param {string} propertyPath - e.g. 'leftShoulderZ'\r\n   * @param {Keyframe[]} keyframes\r\n   */\r\n  constructor(propertyPath, keyframes) {\r\n    this.propertyPath = propertyPath;\r\n    this.keyframes = keyframes;\r\n  }\r\n}\r\n\r\n/**\r\n * An animation clip consisting of multiple tracks.\r\n */\r\nexport class AnimationClip {\r\n  /**\r\n   * @param {string} name\r\n   * @param {number} duration - Duration in ms\r\n   * @param {Track[]} tracks\r\n   * @param {boolean} [loop=false]\r\n   */\r\n  constructor(name, duration, tracks, loop = false) {\r\n    this.name = name;\r\n    this.duration = duration;\r\n    this.tracks = tracks;\r\n    this.loop = loop;\r\n  }\r\n}\r\n\r\n/**\r\n * Manages playback of animation clips.\r\n */\r\nexport class AnimationPlayer {\r\n    constructor() {\r\n      this.currentClip = null;\r\n      this.time = 0;\r\n      this.playing = false;\r\n      this.onFinish = null;\r\n      // blending state\r\n      this.blendActive = false;\r\n      this.blendElapsed = 0;\r\n      this.blendDuration = 0;\r\n      this.initialPose = {};\r\n      this.latestPose = {};\r\n    }\r\n\r\n  /**\r\n   * Play a clip.\r\n   * @param {AnimationClip} clip\r\n   * @param {{loop?: boolean, onFinish?: function, blend?: number}} [opts]\r\n   */\r\n  play(clip, opts = {}) {\r\n     // initialize blending if requested\r\n     if (opts.blend) {\r\n       this.blendActive = true;\r\n       this.blendElapsed = 0;\r\n       this.blendDuration = opts.blend;\r\n       this.initialPose = { ...this.latestPose };\r\n     }\r\n    this.currentClip = clip;\r\n    this.time = 0;\r\n    this.playing = true;\r\n    this.currentClip.loop = opts.loop ?? clip.loop;\r\n    this.onFinish = opts.onFinish || null;\r\n  }\r\n\r\n  /**\r\n   * Stop playback.\r\n   */\r\n  stop() {\r\n    this.playing = false;\r\n  }\r\n\r\n  /** Sample a clip at a given time to generate a pose map */\r\n  samplePose(clip, time) {\r\n    const pose = {};\r\n    for (const track of clip.tracks) {\r\n      const frames = track.keyframes;\r\n      if (!frames.length) continue;\r\n      let i = frames.findIndex(kf => kf.time >= time);\r\n      if (i === -1) pose[track.propertyPath] = frames[frames.length - 1].value;\r\n      else if (i === 0) pose[track.propertyPath] = frames[0].value;\r\n      else {\r\n        const a = frames[i-1], b = frames[i];\r\n        const t0 = (time - a.time) / (b.time - a.time);\r\n        pose[track.propertyPath] = a.value + (b.value - a.value) * t0;\r\n      }\r\n    }\r\n    return pose;\r\n  }\r\n\r\n  /**\r\n   * Update the player by advancing time and sampling.\r\n   */\r\n  update(delta) {\r\n    if (!this.playing || !this.currentClip) return {};\r\n    this.time += delta;\r\n    if (this.time > this.currentClip.duration) {\r\n      if (this.currentClip.loop) this.time %= this.currentClip.duration;\r\n      else { this.time = this.currentClip.duration; this.playing = false; this.onFinish?.(); }\r\n    }\r\n    // Sample target clip pose\r\n    const poseTo = {};\r\n    for (const track of this.currentClip.tracks) {\r\n      const frames = track.keyframes;\r\n      if (!frames.length) continue;\r\n      let i = frames.findIndex(kf => kf.time >= this.time);\r\n      if (i === -1) poseTo[track.propertyPath] = frames[frames.length - 1].value;\r\n      else if (i === 0) poseTo[track.propertyPath] = frames[0].value;\r\n      else {\r\n        const a = frames[i-1], b = frames[i];\r\n        const t0 = (this.time - a.time) / (b.time - a.time);\r\n        poseTo[track.propertyPath] = a.value + (b.value - a.value) * t0;\r\n      }\r\n    }\r\n    // blend and return\r\n    const outPose = this.blendPose(poseTo, delta);\r\n    this.latestPose = outPose;\r\n    return outPose;\r\n  }\r\n\r\n  /**\r\n   * Blend between initialPose and new poseTo based on elapsed time.\r\n   */\r\n  blendPose(poseTo, delta) {\r\n    if (!this.blendActive) return poseTo;\r\n    this.blendElapsed += delta;\r\n    const t = Math.min(this.blendElapsed / this.blendDuration, 1);\r\n    const blended = {};\r\n    for (const key in poseTo) {\r\n      const fromVal = this.initialPose[key] !== undefined ? this.initialPose[key] : poseTo[key];\r\n      blended[key] = fromVal * (1 - t) + poseTo[key] * t;\r\n    }\r\n    if (t === 1) this.blendActive = false;\r\n    return blended;\r\n  }\r\n}\r\n","// Predefined animations for Stickman\r\n\r\nimport { AnimationClip, Track } from './AnimationPlayer.js';\r\n\r\n// Idle animation: slight shoulder swing\r\nexport const idleClip = new AnimationClip(\r\n  'idle',\r\n  1000, // duration in ms\r\n  [\r\n    new Track('leftShoulderZ', [\r\n      { time: 0, value: -0.2 },\r\n      { time: 500, value: 0.2 },\r\n      { time: 1000, value: -0.2 }\r\n    ]),\r\n    new Track('rightShoulderZ', [\r\n      { time: 0, value: 0.2 },\r\n      { time: 500, value: -0.2 },\r\n      { time: 1000, value: 0.2 }\r\n    ])\r\n  ],\r\n  true // loop\r\n);\r\n\r\n// Walking animation: swing limbs to mimic walk\r\nexport const walkClip = new AnimationClip(\r\n  'walk',\r\n  600, // duration\r\n  [\r\n    new Track('leftHipZ', [ { time: 0, value: -0.4 }, { time: 300, value: 0.4 }, { time: 600, value: -0.4 } ]),\r\n    new Track('rightHipZ', [ { time: 0, value: 0.4 }, { time: 300, value: -0.4 }, { time: 600, value: 0.4 } ]),\r\n    new Track('leftShoulderZ', [ { time: 0, value: 0.5 }, { time: 300, value: -0.5 }, { time: 600, value: 0.5 } ]),\r\n    new Track('rightShoulderZ', [ { time: 0, value: -0.5 }, { time: 300, value: 0.5 }, { time: 600, value: -0.5 } ]),\r\n    new Track('leftKneeZ', [ { time: 0, value: 0.2 }, { time: 300, value: -0.2 }, { time: 600, value: 0.2 } ]),\r\n    new Track('rightKneeZ', [ { time: 0, value: -0.2 }, { time: 300, value: 0.2 }, { time: 600, value: -0.2 } ])\r\n  ],\r\n  true\r\n);\r\n","// Core skeleton and forward kinematics for stick-fighter animation\r\n\r\n/**\r\n * A single bone in the skeleton hierarchy.\r\n */\r\nexport class Bone {\r\n  constructor(length, parent = null) {\r\n    this.length = length;\r\n    this.localAngle = 0;    // angle relative to parent\r\n    this.worldAngle = 0;    // absolute angle in world space\r\n    this.parent = parent;\r\n    this.children = [];\r\n    this.startPoint = { x: 0, y: 0 };\r\n    this.endPoint = { x: length, y: 0 };\r\n    if (parent) parent.addChild(this);\r\n  }\r\n\r\n  addChild(child) {\r\n    this.children.push(child);\r\n  }\r\n\r\n  /**\r\n   * Recursively update world transform for this bone and its children.\r\n   * @param {{x:number,y:number}} parentStart - world start point of parent\r\n   * @param {number} parentAngle - world angle of parent\r\n   */\r\n  updateWorldTransform(parentStart = { x: 0, y: 0 }, parentAngle = 0) {\r\n    this.worldAngle = parentAngle + this.localAngle;\r\n    this.startPoint.x = parentStart.x;\r\n    this.startPoint.y = parentStart.y;\r\n    this.endPoint.x = this.startPoint.x + Math.cos(this.worldAngle) * this.length;\r\n    this.endPoint.y = this.startPoint.y + Math.sin(this.worldAngle) * this.length;\r\n    this.children.forEach(child => child.updateWorldTransform(this.endPoint, this.worldAngle));\r\n  }\r\n}\r\n\r\n/**\r\n * A skeleton containing a root bone and convenience methods.\r\n */\r\nexport class Skeleton {\r\n  constructor(rootBone) {\r\n    this.root = rootBone;\r\n  }\r\n\r\n  /**\r\n   * Update the entire bone chain (FK) from the root.\r\n   */\r\n  update() {\r\n    this.root.updateWorldTransform({ x: 0, y: 0 }, 0);\r\n  }\r\n}\r\n\r\n/**\r\n * Draw a cylindrical bone between two points.\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x:number,y:number}} p1\r\n * @param {{x:number,y:number}} p2\r\n * @param {number} width\r\n * @param {string} color\r\n */\r\nexport function drawBoneCylinder(ctx, p1, p2, width, color) {\r\n  const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\r\n  ctx.save();\r\n  ctx.lineWidth = width;\r\n  ctx.lineCap = 'round';\r\n  ctx.strokeStyle = color;\r\n  ctx.beginPath();\r\n  ctx.moveTo(p1.x, p1.y);\r\n  ctx.lineTo(p2.x, p2.y);\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n","// hitSparks.js - Modular, extensible hit spark/impact effect system for Stick Fighter\n// Author: Modularized & enhanced for ES module architecture\n\nimport { eventManager } from './eventManager.js';\nimport {\n  // no constants needed here, keep imports minimal\n} from './constants.js';\n\n/**\n * HitSparkType registry for extensibility (different visual/sound effects)\n */\nexport const HIT_SPARK_TYPES = Object.create(null);\n\n// --- Advanced Features for 2D Fighting Game HitSparks ---\n\n/**\n * 1. Directional and Impact-Based Effects\n * 2. Color/Style Customization by Move/Character\n * 3. Animated/Multi-Frame Sprites\n * 4. Screen Shake/Camera Effects\n * 5. Combo/Chain Reaction & Sound Layering\n */\n\n// --- Sprite/animation frame cache (for animated sparks) ---\nconst _spriteCache = {};\n\n/**\n * Register a hit spark type with advanced options\n * @param {string} type\n * @param {object} config\n *   - color, particleCount, duration, size, sound, style, spriteSheet, frames, animSpeed, screenShake, flash, slowMo, soundLayer, etc.\n */\nexport function registerHitSparkType(type, config) {\n  if (!type || typeof config !== 'object') throw new Error('registerHitSparkType: Invalid arguments');\n  HIT_SPARK_TYPES[type] = { ...config };\n  if (config.spriteSheet && typeof window !== 'undefined') {\n    // Preload sprite sheet if provided\n    if (!_spriteCache[type]) {\n      const img = new window.Image();\n      img.src = config.spriteSheet;\n      _spriteCache[type] = img;\n    }\n  }\n  eventManager?.dispatchEvent('hitSparkTypeRegistered', { type, config });\n}\n\nexport function unregisterHitSparkType(type) {\n  if (HIT_SPARK_TYPES[type]) {\n    delete HIT_SPARK_TYPES[type];\n    eventManager?.dispatchEvent('hitSparkTypeUnregistered', { type });\n  }\n}\n\n// Default hit spark types\nregisterHitSparkType('default', {\n  color: '#fff',\n  particleCount: 8,\n  duration: 300,\n  size: 8,\n  sound: null,\n});\nregisterHitSparkType('heavy', {\n  color: '#ff0',\n  particleCount: 16,\n  duration: 500,\n  size: 12,\n  sound: null,\n});\nregisterHitSparkType('critical', {\n  color: '#f00',\n  particleCount: 24,\n  duration: 700,\n  size: 16,\n  sound: null,\n});\n\n/**\n * HitSpark class\n */\nexport class HitSpark {\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {string} type\n   * @param {object} options\n   */\n  constructor(x, y, type = 'default', options = {}) {\n    // --- Core properties ---\n    this.x = x;\n    this.y = y;\n    this.type = type;\n    const def = HIT_SPARK_TYPES[type] || {};\n    this.color = options.color || def.color || '#fff';\n    this.particleCount = options.particleCount || def.particleCount || 8;\n    this.duration = options.duration || def.duration || 300;\n    this.size = options.size || def.size || 8;\n    this.sound = options.sound || def.sound || null;\n    this.spawnTime = Date.now();\n    this.active = true;\n    this.id = options.id || `hitspark_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;\n    this.debug = options.debug || false;\n    this.meta = { ...(def.meta || {}), ...(options.meta || {}) };\n    // --- Advanced ---\n    this.impact = options.impact || {};\n    this.comboCount = options.comboCount || 1;\n    this.spriteSheet = options.spriteSheet || def.spriteSheet || null;\n    this.frames = options.frames || def.frames || null;\n    this.animSpeed = options.animSpeed || def.animSpeed || 1;\n    this.frameIndex = 0;\n    this.frameElapsed = 0;\n    this.style = options.style || def.style || null;\n    this.move = options.move || def.move || null;\n    this.character = options.character || def.character || null;\n    // Particle creation with impact direction/force\n    this.particles = this._createParticles();\n    if (this.sound) this.playSound();\n    eventManager?.dispatchEvent('hitSparkSpawned', { hitSpark: this });\n  }\n\n  _createParticles() {\n    const particles = [];\n    const impact = this.impact || {};\n    let baseAngle = typeof impact.angle === 'number' ? impact.angle : null;\n    let baseForce = typeof impact.force === 'number' ? impact.force : 1;\n    let baseVx = typeof impact.vx === 'number' ? impact.vx : null;\n    let baseVy = typeof impact.vy === 'number' ? impact.vy : null;\n    for (let i = 0; i < this.particleCount; i++) {\n      let angle = baseAngle !== null ? baseAngle + (Math.random() - 0.5) * Math.PI / 3 : (2 * Math.PI * i) / this.particleCount;\n      let force = baseForce + Math.random() * 0.5;\n      let vx = baseVx !== null ? baseVx + (Math.random() - 0.5) : Math.cos(angle) * force;\n      let vy = baseVy !== null ? baseVy + (Math.random() - 0.5) : Math.sin(angle) * force;\n      particles.push({\n        x: this.x,\n        y: this.y,\n        vx,\n        vy,\n        alpha: 1,\n        size: this.size * (0.7 + Math.random() * 0.6),\n      });\n    }\n    return particles;\n  }\n\n  update(delta) {\n    if (!this.active) return;\n    const elapsed = Date.now() - this.spawnTime;\n    if (elapsed > this.duration) {\n      this.active = false;\n      eventManager?.dispatchEvent('hitSparkExpired', { hitSpark: this });\n      return;\n    }\n    // Animated sprite support\n    if (this.frames && this.frames.length > 0) {\n      this.frameElapsed += delta * this.animSpeed;\n      if (this.frameElapsed > 1000 / 60) {\n        this.frameIndex = (this.frameIndex + 1) % this.frames.length;\n        this.frameElapsed = 0;\n      }\n    }\n    for (const p of this.particles) {\n      p.x += p.vx * (delta / (1000 / 60));\n      p.y += p.vy * (delta / (1000 / 60));\n      p.alpha -= 0.03 * (delta / (1000 / 60));\n      if (p.alpha < 0) p.alpha = 0;\n    }\n  }\n\n  draw(ctx) {\n    if (!this.active || !ctx) return;\n    ctx.save();\n    // Animated sprite support\n    if (this.spriteSheet && _spriteCache[this.type]) {\n      // Draw sprite frame at each particle position\n      for (const p of this.particles) {\n        ctx.globalAlpha = p.alpha;\n        // Assume sprite sheet is a horizontal strip, frames equally sized\n        const img = _spriteCache[this.type];\n        const frameW = img.width / (this.frames?.length || 1);\n        const frameH = img.height;\n        const frameIdx = this.frames ? this.frames[this.frameIndex] : 0;\n        ctx.drawImage(img, frameIdx * frameW, 0, frameW, frameH, p.x - frameW/2, p.y - frameH/2, frameW, frameH);\n      }\n    } else {\n      // Fallback: colored particles\n      for (const p of this.particles) {\n        ctx.globalAlpha = p.alpha;\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    ctx.restore();\n  }\n\n  playSound() {\n    if (typeof this.sound === 'function') {\n      this.sound();\n    } else if (typeof window !== 'undefined' && this.sound) {\n      const audio = new window.Audio(this.sound);\n      audio.play();\n    }\n  }\n\n  serialize() {\n    return {\n      id: this.id,\n      x: this.x,\n      y: this.y,\n      type: this.type,\n      color: this.color,\n      particleCount: this.particleCount,\n      duration: this.duration,\n      size: this.size,\n      sound: this.sound,\n      spawnTime: this.spawnTime,\n      active: this.active,\n      debug: this.debug,\n      meta: { ...this.meta },\n    };\n  }\n\n  static deserialize(data) {\n    return new HitSpark(data.x, data.y, data.type, data);\n  }\n\n  describe() {\n    return this.serialize();\n  }\n}\n\nexport const hitSparks = [];\n\nexport function spawnHitSpark(x, y, type = 'default', options = {}) {\n  // Directional/impact support\n  const impact = options.impact || {};\n  // Style/move/character override\n  let styleType = type;\n  if (options.style && HIT_SPARK_TYPES[options.style]) styleType = options.style;\n  if (options.move && HIT_SPARK_TYPES[options.move]) styleType = options.move;\n  if (options.character && HIT_SPARK_TYPES[options.character]) styleType = options.character;\n  // Combo/chain escalation\n  const comboCount = _trackCombo();\n  // Camera/screen shake/flash/slowMo\n  const sparkType = HIT_SPARK_TYPES[styleType] || HIT_SPARK_TYPES[type] || {};\n  if (sparkType.screenShake || options.screenShake) {\n    eventManager?.dispatchEvent('hitSparkCameraEffect', { effect: 'shake', strength: sparkType.screenShake || options.screenShake, combo: comboCount });\n  }\n  if (sparkType.flash || options.flash) {\n    eventManager?.dispatchEvent('hitSparkCameraEffect', { effect: 'flash', color: sparkType.flash || options.flash });\n  }\n  if (sparkType.slowMo || options.slowMo) {\n    eventManager?.dispatchEvent('hitSparkCameraEffect', { effect: 'slowMo', duration: sparkType.slowMo || options.slowMo });\n  }\n  // Sound layering for combos\n  if (sparkType.soundLayer && comboCount > 1) {\n    // Play layered/unique sound for combos\n    if (typeof sparkType.soundLayer === 'function') {\n      sparkType.soundLayer(comboCount);\n    } else if (typeof window !== 'undefined' && sparkType.soundLayer) {\n      const audio = new window.Audio(sparkType.soundLayer);\n      audio.volume = Math.min(1, 0.5 + 0.1 * comboCount);\n      audio.play();\n    }\n  }\n  // Pass all options, including impact, style, animation, combo\n  const hs = new HitSpark(x, y, styleType, { ...options, impact, comboCount });\n  hitSparks.push(hs);\n  return hs;\n}\n\n// --- Combo/chain tracking for sound/visual escalation ---\nlet _lastSparkTime = 0;\nlet _comboCount = 0;\nconst COMBO_WINDOW = 250; // ms\n\nfunction _trackCombo() {\n  const now = Date.now();\n  if (now - _lastSparkTime < COMBO_WINDOW) {\n    _comboCount++;\n  } else {\n    _comboCount = 1;\n  }\n  _lastSparkTime = now;\n  return _comboCount;\n}\n\n/**\n * Debug/diagnostics API\n */\nexport const hitSparkDiagnostics = {\n  getAll: () => [...hitSparks],\n  describeAll: describeAllHitSparks,\n  count: () => hitSparks.length,\n};\n\n// --- Utility and supporting features for hitSparks.js ---\n\n/**\n * Get all active hit sparks\n */\nexport function getActiveHitSparks() {\n  return hitSparks.filter(hs => hs.active);\n}\n\n/**\n * Get hit sparks by type\n * @param {string} type\n */\nexport function getHitSparksByType(type) {\n  return hitSparks.filter(hs => hs.type === type);\n}\n\n/**\n * Get hit sparks within a region (bounding box)\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n */\nexport function getHitSparksInRegion(x, y, w, h) {\n  return hitSparks.filter(hs =>\n    hs.active &&\n    hs.x >= x && hs.x <= x + w &&\n    hs.y >= y && hs.y <= y + h\n  );\n}\n\n/**\n * Batch spawn hit sparks (e.g., for multi-hit or area effects)\n * @param {Array<{x:number, y:number, type?:string, options?:object}>} sparks\n */\nexport function spawnHitSparksBatch(sparks) {\n  return sparks.map(s => spawnHitSpark(s.x, s.y, s.type || 'default', s.options || {}));\n}\n\n/**\n * Pause/resume all hit sparks (for game pause)\n */\nlet _paused = false;\nlet _pauseTimestamps = new Map();\nexport function pauseHitSparks() {\n  if (_paused) return;\n  _paused = true;\n  _pauseTimestamps.clear();\n  for (const hs of hitSparks) {\n    if (hs.active) _pauseTimestamps.set(hs.id, Date.now());\n  }\n}\nexport function resumeHitSparks() {\n  if (!_paused) return;\n  const now = Date.now();\n  for (const hs of hitSparks) {\n    if (_pauseTimestamps.has(hs.id)) {\n      hs.spawnTime += now - _pauseTimestamps.get(hs.id);\n    }\n  }\n  _paused = false;\n  _pauseTimestamps.clear();\n}\nexport function isHitSparksPaused() {\n  return _paused;\n}\n\n/**\n * Remove all expired/inactive hit sparks (manual cleanup)\n */\nexport function removeInactiveHitSparks() {\n  for (let i = hitSparks.length - 1; i >= 0; i--) {\n    if (!hitSparks[i].active) hitSparks.splice(i, 1);\n  }\n}\n\n/**\n * Export/import hit sparks for save/load or replay\n */\nexport function exportHitSparks() {\n  return hitSparks.map(hs => hs.serialize());\n}\nexport function importHitSparks(arr) {\n  clearHitSparks();\n  for (const data of arr) {\n    hitSparks.push(HitSpark.deserialize(data));\n  }\n}\n\n/**\n * Attach hit sparks to a moving entity (e.g., trailing effect)\n * @param {object} entity - Must have x, y properties\n * @param {string} type\n * @param {object} options\n */\nexport function attachHitSparkToEntity(entity, type = 'default', options = {}) {\n  if (!entity || typeof entity.x !== 'number' || typeof entity.y !== 'number') return null;\n  return spawnHitSpark(entity.x, entity.y, type, options);\n}\n\n// --- Integration with advanced hitSparks features across all systems ---\nimport { onObstacleDestroyed } from './obstacles.js';\nimport { Stickman } from './stickman.js';\nimport { onComboPerformed } from './controls.js';\n\n// 1. Obstacle integration: directional/impact-based hit sparks\nif (typeof onObstacleDestroyed === 'function') {\n  onObstacleDestroyed((obstacle, { hitter, impact } = {}) => {\n    // Use hitter's velocity or impact info if available\n    let angle = null, force = 1;\n    if (impact && typeof impact.angle === 'number') angle = impact.angle;\n    else if (hitter && typeof hitter.vx === 'number' && typeof hitter.vy === 'number') {\n      angle = Math.atan2(hitter.vy, hitter.vx);\n      force = Math.sqrt(hitter.vx * hitter.vx + hitter.vy * hitter.vy);\n    }\n    spawnHitSpark(\n      obstacle.x,\n      obstacle.y,\n      'heavy',\n      {\n        impact: { angle, force },\n        style: obstacle.type || undefined,\n        screenShake: 8,\n        debug: true\n      }\n    );\n  });\n}\n\n// 2. PowerUp integration: style/color-based hit sparks\nif (eventManager?.subscribe) {\n  eventManager.subscribe('powerupCollected', ({ powerup, player }) => {\n    spawnHitSpark(\n      player.x,\n      player.y,\n      'default',\n      {\n        color: powerup.color,\n        style: powerup.type,\n        impact: { angle: -Math.PI / 2, force: 1.5 },\n        flash: powerup.color,\n        debug: true\n      }\n    );\n  });\n}\n\n// 3. Stickman integration: move/character-based, directional, and combo hit sparks\nif (Stickman?.prototype) {\n  Stickman.prototype.spawnHitSparkOnHit = function(target, move, attackInfo = {}) {\n    // move: string (e.g., 'firePunch'), attackInfo: { angle, force, character }\n    spawnHitSpark(\n      target.x,\n      target.y,\n      move || 'default',\n      {\n        impact: { angle: attackInfo.angle, force: attackInfo.force },\n        style: move,\n        character: this.characterName,\n        screenShake: attackInfo.critical ? 12 : 0,\n        slowMo: attackInfo.critical ? 200 : 0,\n        debug: true\n      }\n    );\n  };\n}\n\n// 4. Controls integration: combo/chain, style, and sound layering\nif (typeof onComboPerformed === 'function') {\n  onComboPerformed((combo, player, comboInfo = {}) => {\n    // comboInfo: { move, angle, force, soundLayer }\n    spawnHitSpark(\n      player.x,\n      player.y,\n      comboInfo.move || 'critical',\n      {\n        impact: { angle: comboInfo.angle, force: comboInfo.force },\n        style: combo,\n        soundLayer: comboInfo.soundLayer,\n        screenShake: 10 + (comboInfo.level || 0) * 2,\n        flash: '#fff',\n        slowMo: 150,\n        debug: true\n      }\n    );\n  });\n}\n\n// 5. Game loop/camera integration: subscribe to camera effect events\nif (eventManager?.subscribe) {\n  eventManager.subscribe('hitSparkCameraEffect', ({ effect, strength, color, duration, combo }) => {\n    // Example: call camera/screen shake/flash/slowMo handlers here\n    if (effect === 'shake' && typeof window !== 'undefined' && window.cameraShake) {\n      window.cameraShake(strength || 8, combo);\n    }\n    if (effect === 'flash' && typeof window !== 'undefined' && window.screenFlash) {\n      window.screenFlash(color || '#fff');\n    }\n    if (effect === 'slowMo' && typeof window !== 'undefined' && window.slowMo) {\n      window.slowMo(duration || 100);\n    }\n  });\n}\n// --- End integration ---\n\n// Auto-spawn hit sparks on damage events\nif (eventManager?.subscribe) {\n  eventManager.subscribe('playerHit', ({ defender, impact }) => {\n    const x = impact?.x ?? defender.x;\n    const y = impact?.y ?? defender.y - defender.height / 2;\n    hitSparks.push(new HitSpark(x, y, impact?.type || 'default', { impact }));\n  });\n}\n\nexport function updateAllHitSparks(delta, context) {\n  for (const hs of hitSparks) {\n    hs.update(delta, context);\n  }\n  // Remove inactive hit sparks after update\n  for (let i = hitSparks.length - 1; i >= 0; i--) {\n    if (!hitSparks[i].active) hitSparks.splice(i, 1);\n  }\n}\n\nexport function describeAllHitSparks() {\n  return hitSparks.map(hs => hs.describe());\n}\n/**\n * Render all active hit sparks on the canvas\n * @param {CanvasRenderingContext2D} ctx\n */\nexport function drawAllHitSparks(ctx) {\n  for (const hs of hitSparks) {\n    try { hs.draw(ctx); } catch (e) { console.error('[hitSparks] Error drawing hit spark:', e); }\n  }\n}","// Stickman class for 2D Stick Fighter (feature-rich, ES module)\n// Dependencies: Import or provide ctx, constants, eventManager, updateHealthBars, checkRectCollision, HitSpark, etc. in your main entry point or as needed.\n\nimport { obstacles, checkObstacleCollision } from './obstacles.js';\nimport {\n  STICKMAN_WIDTH,\n  STICKMAN_HEIGHT,\n  STICKMAN_MASS,\n  STICKMAN_LIMB_LENGTH,\n  LIMB_HITBOX_PADDING,\n  PLAYER_HEALTH_MAX,\n  LIMB_IMPAIR_DURATION,\n  ATTACK_DURATION,\n  SPECIAL_ATTACK_DURATION,\n  GRAVITY\n} from './constants.js';\nimport { AnimationPlayer } from './AnimationPlayer.js';\nimport { idleClip } from './animations.js';\nimport { eventManager } from './eventManager.js';\nimport { drawBoneCylinder } from './skeleton.js';\nimport { spawnHitSpark } from './hitSparks.js';\n\n// --- Stickman Registry for Modular Access ---\nconst stickmanRegistry = [];\n\nexport function registerStickman(instance) {\n  if (!stickmanRegistry.includes(instance)) stickmanRegistry.push(instance);\n}\nexport function unregisterStickman(instance) {\n  const idx = stickmanRegistry.indexOf(instance);\n  if (idx !== -1) stickmanRegistry.splice(idx, 1);\n}\nexport function getAllStickmen() {\n  return [...stickmanRegistry];\n}\n// Update all stickman instances each frame, providing opponent, rendering context, and game state\nexport function updateAllStickmen(delta, context) {\n  const stickmen = getAllStickmen();\n  stickmen.forEach((sm, idx) => {\n    const opponent = stickmen[(idx + 1) % stickmen.length] || null;\n    try {\n      sm.update(opponent, context.ctx, context);\n    } catch (e) {\n      console.error('[updateAllStickmen] Error updating stickman:', e);\n    }\n  });\n}\n\nexport class Stickman {\n    constructor(x, y, colors, isPlayer1, controls = null, isNPC = false, aiType = null) {\n        // Position and movement\n        this.x = x;\n        this.y = y;\n        this.prevX = x;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.width = STICKMAN_WIDTH;\n        this.height = STICKMAN_HEIGHT;\n        this.yBase = y;\n        this.facingRight = isPlayer1;\n        this.isRunning = false;\n        this.isJumping = false;\n        this.mass = STICKMAN_MASS;\n        this.lineWidth = 6;\n\n        // Controls and AI\n        this.isNPC = isNPC;\n        this.controls = controls;\n        this.aiType = aiType;\n        this.aiActionCooldown = 0;\n        this.aiDecisionIntervalBase = 600;\n        this.aiPreferredDistance = 180;\n        this.aiBaseAttackProb = 0.18;\n        this.aiBaseGuardProb = 0.13;\n        this.aiBaseParryProb = 0.08;\n        this.aiBaseJumpProb = 0.07;\n        this.aiTargetX = null;\n        this.aiWantsToAttack = false;\n        this.aiWantsToGuard = false;\n        this.aiWantsToParry = false;\n        this.aiWantsToJump = false;\n\n        // State\n        this.isGuarding = false;\n        this.isParrying = false;\n        this.isDodging = false;\n        this.isAttacking = false;\n        this.isPerformingSpecialMove = false;\n        this.specialMoveType = null;\n        this.attackType = null;\n        this.attackTimer = 0;\n        this.groundSlamImpactDone = false;\n        this.hitStunTimer = 0;\n        this.dodgeTimer = 0;\n        this.dodgeCooldownTimer = 0;\n        this.parryTimer = 0;\n        this.parryCooldownTimer = 0;\n        this.parryFailedVulnTimer = 0;\n        this.comboState = { count: 0, lastAttackTime: 0, lastAttackType: null };\n\n        // Health and limbs\n        this.health = PLAYER_HEALTH_MAX;\n        this.limbImpairDuration = LIMB_IMPAIR_DURATION;\n        this.limbs = {\n            leftUpperArm: { impairedTimer: 0 },\n            leftLowerArm: { impairedTimer: 0 },\n            rightUpperArm: { impairedTimer: 0 },\n            rightLowerArm: { impairedTimer: 0 },\n            leftUpperLeg: { impairedTimer: 0 },\n            leftLowerLeg: { impairedTimer: 0 },\n            rightUpperLeg: { impairedTimer: 0 },\n            rightLowerLeg: { impairedTimer: 0 }\n        };\n        this.colors = colors;\n        this.limbSegmentLength = STICKMAN_LIMB_LENGTH;\n\n        // Animation\n        this.walkCycleTime = 0;\n        this.leftFootPlantedX = null;\n        this.rightFootPlantedX = null;\n        this.activeProceduralAnimation = null;\n        this.currentAngles = this.defaultAngles();\n        this.targetAngles = this.defaultAngles();\n\n        // Animation player setup\n        this.animPlayer = new AnimationPlayer();\n        this.animPlayer.play(idleClip, { loop: true });\n\n        // Listen for loaded player state\n        eventManager.subscribe('loadPlayerState', ({index, state}) => {\n          if (index === gameContext.players.indexOf(this)) {\n            this.x = state.x;\n            this.y = state.y;\n            this.health = state.health;\n            this.facingRight = state.facingRight;\n          }\n        });\n        registerStickman(this);\n        this.idleTime = 0;\n    }\n\n    defaultAngles() {\n        return {\n            leftShoulderZ: 0, rightShoulderZ: 0,\n            leftElbowZ: 0, rightElbowZ: 0,\n            leftHipZ: 0, rightHipZ: 0,\n            leftKneeZ: 0, rightKneeZ: 0\n        };\n    }\n\n    getJointPositions() {\n        const { x, y, width, height, limbSegmentLength } = this;\n        // Basic skeleton: hip, neck, head, shoulders, elbows, hands, knees, feet\n        const hip = { x, y };\n        const neck = { x, y: y - height * 0.4 };\n        const head = { cx: x, cy: y - height * 0.6, radius: width * 0.5 };\n        const leftShoulder = { x: neck.x - limbSegmentLength, y: neck.y };\n        const rightShoulder = { x: neck.x + limbSegmentLength, y: neck.y };\n        const leftElbow = { x: leftShoulder.x - limbSegmentLength, y: leftShoulder.y + limbSegmentLength };\n        const rightElbow = { x: rightShoulder.x + limbSegmentLength, y: rightShoulder.y + limbSegmentLength };\n        const leftHand = { x: leftElbow.x - limbSegmentLength, y: leftElbow.y };\n        const rightHand = { x: rightElbow.x + limbSegmentLength, y: rightElbow.y };\n        const leftKnee = { x: hip.x - limbSegmentLength / 2, y: hip.y + limbSegmentLength };\n        const rightKnee = { x: hip.x + limbSegmentLength / 2, y: hip.y + limbSegmentLength };\n        const leftFoot = { x: leftKnee.x, y: leftKnee.y + limbSegmentLength };\n        const rightFoot = { x: rightKnee.x, y: rightKnee.y + limbSegmentLength };\n        return { hip, neck, head, leftShoulder, rightShoulder, leftElbow, rightElbow, leftHand, rightHand, leftKnee, rightKnee, leftFoot, rightFoot };\n    }\n\n    getLimbColor(limb) {\n        return this.colors[limb] || '#000';\n    }\n\n    getLimbHitboxes() {\n        const joints = this.getJointPositions();\n        const hitboxes = {};\n        const p = LIMB_HITBOX_PADDING;\n        hitboxes.head = { type: 'circle', cx: joints.head?.cx, cy: joints.head?.cy, radius: (joints.head?.radius || 0) + p };\n        const createSegmentAABB = (p1, p2) => ({\n            type: 'rect',\n            x: Math.min(p1.x, p2.x) - p,\n            y: Math.min(p1.y, p2.y) - p,\n            width: Math.abs(p1.x - p2.x) + 2 * p,\n            height: Math.abs(p1.y - p2.y) + 2 * p\n        });\n        hitboxes.torso = createSegmentAABB(joints.neck, joints.hip);\n        if (this.facingRight) {\n            hitboxes.rightUpperArm = createSegmentAABB(joints.rightShoulder, joints.rightElbow);\n            hitboxes.rightLowerArm = createSegmentAABB(joints.rightElbow, joints.rightHand);\n            hitboxes.leftUpperArm = createSegmentAABB(joints.leftShoulder, joints.leftElbow);\n            hitboxes.leftLowerArm = createSegmentAABB(joints.leftElbow, joints.leftHand);\n            hitboxes.rightUpperLeg = createSegmentAABB(joints.hip, joints.rightKnee);\n            hitboxes.rightLowerLeg = createSegmentAABB(joints.rightKnee, joints.rightFoot);\n            hitboxes.leftUpperLeg = createSegmentAABB(joints.hip, joints.leftKnee);\n            hitboxes.leftLowerLeg = createSegmentAABB(joints.leftKnee, joints.leftFoot);\n        } else {\n            hitboxes.leftUpperArm = createSegmentAABB(joints.leftShoulder, joints.leftElbow);\n            hitboxes.leftLowerArm = createSegmentAABB(joints.leftElbow, joints.leftHand);\n            hitboxes.rightUpperArm = createSegmentAABB(joints.rightShoulder, joints.rightElbow);\n            hitboxes.rightLowerArm = createSegmentAABB(joints.rightElbow, joints.rightHand);\n            hitboxes.leftUpperLeg = createSegmentAABB(joints.hip, joints.leftKnee);\n            hitboxes.leftLowerLeg = createSegmentAABB(joints.leftKnee, joints.leftFoot);\n            hitboxes.rightUpperLeg = createSegmentAABB(joints.hip, joints.rightKnee);\n            hitboxes.rightLowerLeg = createSegmentAABB(joints.rightKnee, joints.rightFoot);\n        }\n        for (const key in hitboxes) {\n            if (hitboxes[key].type === 'rect') {\n                if (hitboxes[key].width < 2 * p) hitboxes[key].width = 2 * p;\n                if (hitboxes[key].height < 2 * p) hitboxes[key].height = 2 * p;\n            }\n        }\n        return hitboxes;\n    }\n\n    draw(ctx) {\n      const joints = this.getJointPositions();\n      if (!joints || !joints.neck) return; // nothing to draw yet\n      ctx.save();\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      ctx.lineWidth = this.lineWidth;\n        // Torso\n        drawBoneCylinder(ctx, joints.neck, joints.hip, this.lineWidth, this.getLimbColor('torso'));\n      // Draw head with gradient shading\n      const headColor = this.getLimbColor('head');\n      const grad = ctx.createRadialGradient(joints.head.cx, joints.head.cy, joints.head.radius * 0.3, joints.head.cx, joints.head.cy, joints.head.radius);\n      grad.addColorStop(0, headColor);\n      // darker towards rim\n      grad.addColorStop(1, '#00000033');\n      ctx.fillStyle = grad;\n       ctx.beginPath();\n       ctx.arc(joints.head?.cx, joints.head?.cy, joints.head?.radius || 0, 0, Math.PI * 2);\n       ctx.fill();\n      ctx.strokeStyle = this.colors.headOutline || '#000';\n      ctx.stroke();\n        // Arms and legs with cylinder rendering\n        drawBoneCylinder(ctx, joints.leftShoulder, joints.leftElbow, this.lineWidth, this.getLimbColor('leftUpperArm'));\n         ctx.strokeStyle = this.getLimbColor('leftLowerArm');\n         ctx.beginPath();\n         ctx.moveTo(joints.leftElbow.x, joints.leftElbow.y);\n         ctx.lineTo(joints.leftHand.x, joints.leftHand.y);\n         ctx.stroke();\n        drawBoneCylinder(ctx, joints.rightShoulder, joints.rightElbow, this.lineWidth, this.getLimbColor('rightUpperArm'));\n         ctx.strokeStyle = this.getLimbColor('rightLowerArm');\n         ctx.beginPath();\n         ctx.moveTo(joints.rightElbow.x, joints.rightElbow.y);\n         ctx.lineTo(joints.rightHand.x, joints.rightHand.y);\n         ctx.stroke();\n        drawBoneCylinder(ctx, joints.hip, joints.leftKnee, this.lineWidth, this.getLimbColor('leftUpperLeg'));\n         ctx.strokeStyle = this.getLimbColor('leftLowerLeg');\n         ctx.beginPath();\n         ctx.moveTo(joints.leftKnee.x, joints.leftKnee.y);\n         ctx.lineTo(joints.leftFoot.x, joints.leftFoot.y);\n         ctx.stroke();\n        drawBoneCylinder(ctx, joints.hip, joints.rightKnee, this.lineWidth, this.getLimbColor('rightUpperLeg'));\n         ctx.strokeStyle = this.getLimbColor('rightLowerLeg');\n         ctx.beginPath();\n         ctx.moveTo(joints.rightKnee.x, joints.rightKnee.y);\n         ctx.lineTo(joints.rightFoot.x, joints.rightFoot.y);\n         ctx.stroke();\n        // Draw special move effect if needed\n        if (this.specialMoveType === 'groundSlam' && this.y >= GROUND_LEVEL - this.height / 2 - 5 && !this.groundSlamImpactDone) {\n            ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';\n            ctx.lineWidth = 3;\n            for (let i = 0; i < 5; i++) {\n                ctx.beginPath();\n                ctx.arc(this.x, GROUND_LEVEL, (i + 1) * 15, Math.PI, Math.PI * 2);\n                ctx.stroke();\n            }\n        }\n        ctx.restore();\n    }\n\n    /**\n     * Play a custom animation clip via API\n     */\n    playAnimation(clip, opts) {\n      this.animPlayer.play(clip, opts);\n    }\n\n    // --- Animation and Movement ---\n    solveLegIK(targetX, targetY, isLeftLeg) {\n      // Two-bone IK for leg: hip->knee->foot\n      const l1 = this.limbSegmentLength;\n      const l2 = this.limbSegmentLength;\n      const hipX = this.x;\n      const hipY = this.y;\n      const dx = targetX - hipX;\n      const dy = targetY - hipY;\n      let dist = Math.hypot(dx, dy);\n      dist = Math.min(Math.max(dist, Math.abs(l1 - l2) + 0.0001), l1 + l2 - 0.0001);\n      const angleToTarget = Math.atan2(dy, dx);\n      const cosAngle = (l1*l1 + dist*dist - l2*l2) / (2*l1*dist);\n      const hipAngle = angleToTarget - Math.acos(cosAngle);\n      const kneeAngle = Math.PI - Math.acos((l1*l1 + l2*l2 - dist*dist)/(2*l1*l2));\n      const side = isLeftLeg ? 'left' : 'right';\n      this.currentAngles[`${side}HipZ`] = hipAngle;\n      this.currentAngles[`${side}KneeZ`] = kneeAngle;\n    }\n    updateTargetAngles() {\n      // Basic procedural: copy sampled pose as target\n      this.targetAngles = { ...this.currentAngles };\n    }\n    applyProceduralAnimation(baseArmAngle, baseElbowAngle, baseHipAngle, baseKneeAngle) {\n      // Blend to targetAngles if needed\n      for (const key in this.targetAngles) {\n        // simple smoothing\n        this.currentAngles[key] += (this.targetAngles[key] - this.currentAngles[key]) * 0.2;\n      }\n    }\n    applyWalkingAngles(dir, armSwing, elbowBend, hipSwing, kneeBend) {\n      // Arms\n      this.currentAngles.leftShoulderZ = -armSwing * dir;\n      this.currentAngles.rightShoulderZ = armSwing * dir;\n      this.currentAngles.leftElbowZ = elbowBend;\n      this.currentAngles.rightElbowZ = elbowBend;\n      // Legs\n      this.currentAngles.leftHipZ = hipSwing * dir;\n      this.currentAngles.rightHipZ = -hipSwing * dir;\n      this.currentAngles.leftKneeZ = kneeBend;\n      this.currentAngles.rightKneeZ = kneeBend;\n    }\n    applyIdleAngles(dir, idleArm, idleElbow) {\n      // Slight idle sway on shoulders and elbows\n      this.currentAngles.leftShoulderZ += -idleArm * dir;\n      this.currentAngles.rightShoulderZ += idleArm * dir;\n      this.currentAngles.leftElbowZ += idleElbow;\n      this.currentAngles.rightElbowZ += idleElbow;\n    }\n\n    // --- Game Logic ---\n    update(opponent, ctx, gameState) {\n      const { delta, canvasHeight } = gameState;\n      // Update animation pose\n      const pose = this.animPlayer.update(delta);\n      for (const prop in pose) {\n        this.currentAngles[prop] = pose[prop];\n      }\n      // Procedural animation blending: walking vs idle\n      if (Math.abs(this.velocityX) > 0.1) {\n        this.walkCycleTime += delta * 0.01;\n        const cycle = this.walkCycleTime;\n        const armSwing = 0.5 * Math.sin(cycle);\n        const elbowBend = 0.3 * Math.cos(cycle);\n        const hipSwing = 0.4 * Math.sin(cycle);\n        const kneeBend = 0.2 * Math.cos(cycle);\n        const dir = this.facingRight ? 1 : -1;\n        this.applyWalkingAngles(dir, armSwing, elbowBend, hipSwing, kneeBend);\n      } else {\n        this.idleTime += delta * 0.005;\n        const idleArm = 0.2 * Math.sin(this.idleTime);\n        const idleElbow = 0.1 * Math.cos(this.idleTime);\n        const dir = this.facingRight ? 1 : -1;\n        this.applyIdleAngles(dir, idleArm, idleElbow);\n      }\n      // Apply gravity\n      this.velocityY += GRAVITY * delta;\n      // Update position\n      this.y += this.velocityY;\n      this.x += this.velocityX;\n      // Ground collision\n      const groundY = canvasHeight - this.height / 2;\n      if (this.y >= groundY) {\n        this.y = groundY;\n        this.velocityY = 0;\n        this.isJumping = false;\n      }\n      // Face opponent automatically\n      if (opponent && this.canChangeFacing()) {\n        this.facingRight = opponent.x > this.x;\n      }\n    }\n    canAct() {\n        return this.hitStunTimer <= 0 && this.parryFailedVulnTimer <= 0 && !this.isDodging && !this.isParrying && !this.isAttacking && !this.isPerformingSpecialMove && !this.activeProceduralAnimation;\n    }\n    canMove() {\n        return !this.isGuarding && !this.isParrying && !(this.isPerformingSpecialMove && this.specialMoveType === 'groundSlam') && !this.activeProceduralAnimation && this.hitStunTimer <= 0 && this.parryFailedVulnTimer <= 0 && !this.isDodging;\n    }\n    canChangeFacing() {\n        return !this.isAttacking && !this.isPerformingSpecialMove && !this.activeProceduralAnimation && this.hitStunTimer <= 0 && this.parryFailedVulnTimer <= 0 && !this.isParrying && !this.isDodging && !this.isGuarding;\n    }\n    turnAround() {\n        if (!this.canChangeFacing()) return;\n        this.facingRight = !this.facingRight;\n        this.walkCycleTime += Math.PI;\n        [this.leftFootPlantedX, this.rightFootPlantedX] = [this.rightFootPlantedX, this.leftFootPlantedX];\n        if (Math.abs(this.velocityX) < 0.01) {\n            this.leftFootPlantedX = this.rightFootPlantedX = null;\n        }\n        // Flip limb angles to match new facing direction\n        [this.currentAngles.leftShoulderZ, this.currentAngles.rightShoulderZ] = [-this.currentAngles.rightShoulderZ, -this.currentAngles.leftShoulderZ];\n        [this.currentAngles.leftElbowZ, this.currentAngles.rightElbowZ] = [this.currentAngles.rightElbowZ, this.currentAngles.leftElbowZ];\n        [this.currentAngles.leftHipZ, this.currentAngles.rightHipZ] = [-this.currentAngles.rightHipZ, -this.currentAngles.leftHipZ];\n        [this.currentAngles.leftKneeZ, this.currentAngles.rightKneeZ] = [this.currentAngles.rightKneeZ, this.currentAngles.leftKneeZ];\n        // Also update target angles to match\n        [this.targetAngles.leftShoulderZ, this.targetAngles.rightShoulderZ] = [-this.targetAngles.rightShoulderZ, -this.targetAngles.leftShoulderZ];\n        [this.targetAngles.leftElbowZ, this.targetAngles.rightElbowZ] = [this.targetAngles.rightElbowZ, this.targetAngles.leftElbowZ];\n        [this.targetAngles.leftHipZ, this.targetAngles.rightHipZ] = [-this.targetAngles.rightHipZ, -this.targetAngles.leftHipZ];\n        [this.targetAngles.leftKneeZ, this.targetAngles.rightKneeZ] = [this.targetAngles.rightKneeZ, this.targetAngles.leftKneeZ];\n    }\n    jump(force) {\n        if (!this.isJumping) {\n            this.velocityY = force;\n            this.isJumping = true;\n        }\n    }\n    initiateAttack(attackType, opponent) {\n        if (this.canAct()) {\n            this.isAttacking = true;\n            this.attackType = attackType;\n            this.attackTimer = ATTACK_DURATION;\n            this.activeProceduralAnimation = {\n                type: attackType,\n                startTime: Date.now(),\n                duration: ATTACK_DURATION,\n                startAngles: { ...this.currentAngles }\n            };\n            if (this.isJumping && attackType === 'punch') {\n                this.isPerformingSpecialMove = true;\n                this.specialMoveType = 'flyingKick';\n                this.attackTimer = SPECIAL_ATTACK_DURATION;\n            }\n            this.checkHit(opponent);\n        }\n    }\n    initiateSpecialMove(moveType, opponent) {\n        if (this.canAct() && this.isJumping) {\n            this.isPerformingSpecialMove = true;\n            this.specialMoveType = moveType;\n            this.attackTimer = SPECIAL_ATTACK_DURATION;\n            if (moveType === 'groundSlam') {\n                this.velocityY = GROUND_SLAM_FORCE;\n                this.groundSlamImpactDone = false;\n            }\n            this.checkHit(opponent);\n        }\n    }\n    initiateParry() {\n        if (this.canAct() && this.parryCooldownTimer <= 0) {\n            this.isParrying = true;\n            this.parryTimer = PARRY_DURATION;\n            this.parryCooldownTimer = PARRY_COOLDOWN;\n        }\n    }\n    initiateAirDodge(dx, dy) {\n        if (this.canAct() && this.isJumping && this.dodgeCooldownTimer <= 0) {\n            this.isDodging = true;\n            this.dodgeTimer = AIR_DODGE_DURATION;\n            this.dodgeCooldownTimer = AIR_DODGE_COOLDOWN;\n            this.velocityX += dx * AIR_DODGE_FORCE;\n            this.velocityY += dy * AIR_DODGE_FORCE;\n        }\n    }\n    checkHit(opponent) {\n        // ...implement hit detection and effects...\n    }\n    takeDamage(damage, attacker) {\n        // Basic damage application\n        this.health = Math.max(0, this.health - damage);\n        // Spawn hit spark at defender's chest position\n        spawnHitSpark(this.x, this.y - this.height * 0.3, 'default', { impact: { x: this.x, y: this.y - this.height * 0.3 } });\n        // Play hit sound effect if available\n        try {\n          const audio = window.gameAssets?.hitSound;\n          if (audio) {\n            const sfx = audio.cloneNode();\n            sfx.currentTime = 0;\n            sfx.play().catch(e => console.warn('SFX play failed:', e));\n          }\n        } catch (e) {\n          console.warn('Error playing hit sound:', e);\n        }\n        // Dispatch hit event for UI, SFX, etc.\n        eventManager.dispatchEvent('playerHit', { defender: this, attacker, impact: { x: this.x, y: this.y - this.height * 0.3 } });\n    }\n    getHitLimbs(attacker) {\n        // ...implement limb hit detection...\n        return ['torso'];\n    }\n    facingTowards(opponent) {\n        return (this.facingRight && opponent.x > this.x) || (!this.facingRight && opponent.x < this.x);\n    }\n    getAttackRange() {\n        if (this.specialMoveType === 'flyingKick') return FLYING_KICK_RANGE;\n        if (this.specialMoveType === 'groundSlam') return GROUND_SLAM_AOE_RANGE;\n        if (this.attackType === 'punch') return PUNCH_RANGE;\n        if (this.attackType === 'kick') return KICK_RANGE;\n        return 0;\n    }\n    getDamage() {\n        if (this.specialMoveType === 'flyingKick') return FLYING_KICK_DAMAGE;\n        if (this.specialMoveType === 'groundSlam') return GROUND_SLAM_DAMAGE;\n        if (this.attackType === 'punch') return PUNCH_DAMAGE;\n        if (this.attackType === 'kick') return KICK_DAMAGE;\n        return 0;\n    }\n    getKnockback() {\n        let multiplier = this.isPerformingSpecialMove ? KNOCKBACK_SPECIAL_MULTIPLIER : 1;\n        return { x: KNOCKBACK_BASE_X * multiplier, y: KNOCKBACK_BASE_Y * multiplier };\n    }\n    updateComboState() {\n        const now = Date.now();\n        if (now - this.comboState.lastAttackTime <= COMBO_WINDOW && this.comboState.lastAttackType === this.attackType) {\n            this.comboState.count++;\n        } else {\n            this.comboState.count = 1;\n        }\n        this.comboState.lastAttackTime = now;\n        this.comboState.lastAttackType = this.attackType;\n    }\n    handleParrySuccess(opponent) {\n        opponent.hitStunTimer = HIT_STUN_DURATION_HEAVY * PARRY_SUCCESS_STUN_MULTIPLIER;\n        this.parryFailedVulnTimer = PARRY_FAIL_VULNERABLE_DURATION;\n    }\n    handleGroundSlamImpact(opponent) {\n        if (this.groundSlamImpactDone) return;\n        this.groundSlamImpactDone = true;\n        const distance = Math.abs(this.x - opponent.x);\n        if (distance <= GROUND_SLAM_AOE_RANGE) {\n            opponent.takeDamage(GROUND_SLAM_DAMAGE, this);\n            opponent.velocityY = KNOCKBACK_BASE_Y * 2;\n            opponent.hitStunTimer = HIT_STUN_DURATION_HEAVY;\n            // Add hit spark effect here if needed\n        }\n    }\n    // --- AI ---\n    aiDecideAction(opponent) {\n        if (!opponent) return;\n        const distance = Math.abs(this.x - opponent.x);\n        this.aiActionCooldown = this.aiDecisionIntervalBase + Math.random() * 200;\n        if (distance < this.aiPreferredDistance * 0.7) {\n            this.aiTargetX = opponent.x > this.x ? this.x - 100 : this.x + 100;\n        } else if (distance > this.aiPreferredDistance * 1.3) {\n            this.aiTargetX = opponent.x;\n        } else {\n            this.aiTargetX = this.x;\n        }\n        this.aiWantsToAttack = Math.random() < this.aiBaseAttackProb * (this.aiPreferredDistance / Math.max(distance, 1));\n        this.aiWantsToGuard = Math.random() < this.aiBaseGuardProb;\n        this.aiWantsToParry = Math.random() < this.aiBaseParryProb;\n        this.aiWantsToJump = Math.random() < this.aiBaseJumpProb;\n    }\n    aiExecuteAction(opponent, maxSpeed) {\n        if (this.aiTargetX !== null) {\n            const direction = this.aiTargetX > this.x ? 1 : -1;\n            this.velocityX = Math.min(Math.abs(this.velocityX) + BASE_PLAYER_ACCELERATION, maxSpeed) * direction;\n            if (Math.abs(this.x - this.aiTargetX) < 10) this.aiTargetX = null;\n        }\n        if (this.aiWantsToAttack && this.canAct()) {\n            const attackType = Math.random() < 0.5 ? 'punch' : 'kick';\n            this.initiateAttack(attackType, opponent);\n            this.aiWantsToAttack = false;\n        }\n        if (this.aiWantsToGuard && this.canAct()) {\n            this.isGuarding = true;\n        }\n        if (this.aiWantsToParry && this.canAct()) {\n            this.initiateParry();\n            this.aiWantsToParry = false;\n        }\n        if (this.aiWantsToJump && !this.isJumping && this.canAct()) {\n            this.jump(JUMP_FORCE);\n            this.aiWantsToJump = false;\n        }\n    }\n}\n\n// Example integration for stickman.js (if not already modularized):\n// import { Stickman } from './stickman.js';\n// ...\n// In your main entry point or game setup, pass controls to modules that need input state or combos.\n// For example, in stickman.js or player logic:\n//\n// function handlePlayerInput(player, controlsModule = controls) {\n//     const actions = controlsModule.getPressedActions(player);\n//     // Use actions array to drive movement, attacks, etc.\n//     // Optionally, listen for combos:\n//     controlsModule.setComboCallback(comboSequence => {\n//         // Handle combo for this player\n//     });\n// }\n\n// Example: Stickman can query obstacles for AI or movement decisions\nexport function getObstacleDecisionContext(stickman) {\n  // Returns the closest relevant obstacle description for the stickman\n  const stickRect = {\n    x: stickman.x - stickman.width / 2,\n    y: stickman.y - stickman.height,\n    width: stickman.width,\n    height: stickman.height,\n    facingRight: stickman.facingRight\n  };\n  // Find obstacles in front (within 1.5x width)\n  const range = stickman.width * 1.5;\n  const facingRight = stickman.facingRight !== false;\n  const probeRect = {\n    x: facingRight ? stickRect.x + stickRect.width : stickRect.x - range,\n    y: stickRect.y,\n    width: range,\n    height: stickRect.height\n  };\n  const obs = obstacles.find(o => checkObstacleCollision(probeRect));\n  return obs ? obs.describe() : null;\n}","// filepath: src/game/constants.js\r\n// Shared game constants for Stick Fighter\r\nexport const STICKMAN_WIDTH = 32;\r\nexport const STICKMAN_HEIGHT = 64;\r\nexport const STICKMAN_MASS = 1;\r\nexport const STICKMAN_LIMB_LENGTH = 20;\r\nexport const LIMB_HITBOX_PADDING = 4;\r\nexport const PLAYER_HEALTH_MAX = 100;\r\nexport const LIMB_IMPAIR_DURATION = 2000;\r\nexport const ATTACK_DURATION = 300;\r\nexport const SPECIAL_ATTACK_DURATION = 500;\r\n\r\n// Gravity acceleration (pixels per ms²)\r\nexport const GRAVITY = 0.001;\r\n","// ai.js - Modular, extensible AI system for Stick Fighter\n// Author: Modularized & enhanced for ES module architecture\n\nimport { gameContext, registerSystem, logDiagnostic } from './gameContext.js';\nimport { eventManager } from './eventManager.js';\nimport { getScreenState } from '../ui/screenManager.js';\n\n/**\n * AI Behavior Registry for extensibility\n */\nexport const AI_BEHAVIORS = Object.create(null);\n\n/**\n * Allow dynamic injection of additional behavior registries (for plugins/expansion)\n */\nconst _behaviorRegistries = [AI_BEHAVIORS];\nexport function injectBehaviorRegistry(registry) {\n  if (registry && typeof registry === 'object' && !_behaviorRegistries.includes(registry)) {\n    _behaviorRegistries.push(registry);\n  }\n}\nfunction getBehaviorFnFromRegistries(name) {\n  for (const reg of _behaviorRegistries) {\n    if (reg[name]) return reg[name];\n  }\n  return undefined;\n}\n\nexport function registerAIBehavior(name, behaviorFn) {\n  if (!name || typeof behaviorFn !== 'function') throw new Error('registerAIBehavior: Invalid arguments');\n  AI_BEHAVIORS[name] = behaviorFn;\n  eventManager?.dispatchEvent('aiBehaviorRegistered', { name });\n}\n\nexport function unregisterAIBehavior(name) {\n  if (AI_BEHAVIORS[name]) {\n    delete AI_BEHAVIORS[name];\n    eventManager?.dispatchEvent('aiBehaviorUnregistered', { name });\n  }\n}\n\n/**\n * AIController plugin system for extensibility\n */\nclass AIPlugin {\n  // Base plugin class for type checking and docs\n  onAttach(ai) {}\n  onDetach(ai) {}\n  onUpdate(ai, delta, context) {}\n  onEvent(ai, eventName, payload) {}\n}\n\n/**\n * AIController class for managing AI on a stickman/enemy\n * Now supports plugin system and per-instance event hooks\n */\nexport class AIController {\n  /**\n   * @param {object} entity - The stickman/enemy instance\n   * @param {string} behavior - The name of the registered AI behavior\n   * @param {object} options - Custom options for this AI\n   */\n  constructor(entity, behavior = 'basic', options = {}) {\n    this.entity = entity;\n    this.behavior = behavior;\n    this.options = { ...options };\n    this.state = {};\n    // Initialize AIController runtime properties\n    this.debug = options.debug || false;\n    this.lastDecision = 0;\n    this.decisionInterval = options.decisionInterval || 100; // ms\n    this.active = true;\n    this.plugins = [];\n    this.eventHooks = Object.create(null);\n\n    // Register this AIController instance in shared context\n    gameContext.aiControllers.push(this);\n    addAIController(this);\n    eventManager?.dispatchEvent('aiControllerCreated', { ai: this });\n    // Also add to module-level AI list\n    aiControllers.push(this);\n  }\n\n  /**\n   * Attach a plugin (must implement AIPlugin interface)\n   */\n  attachPlugin(plugin) {\n    if (plugin && typeof plugin === 'object' && !this.plugins.includes(plugin)) {\n      this.plugins.push(plugin);\n      plugin.onAttach?.(this);\n    }\n  }\n  /**\n   * Detach a plugin\n   */\n  detachPlugin(plugin) {\n    const idx = this.plugins.indexOf(plugin);\n    if (idx !== -1) {\n      this.plugins.splice(idx, 1);\n      plugin.onDetach?.(this);\n    }\n  }\n  /**\n   * Add a per-instance event hook\n   */\n  addEventHook(eventName, fn) {\n    if (!this.eventHooks[eventName]) this.eventHooks[eventName] = [];\n    this.eventHooks[eventName].push(fn);\n  }\n  /**\n   * Remove a per-instance event hook\n   */\n  removeEventHook(eventName, fn) {\n    if (!this.eventHooks[eventName]) return;\n    const idx = this.eventHooks[eventName].indexOf(fn);\n    if (idx !== -1) this.eventHooks[eventName].splice(idx, 1);\n  }\n  /**\n   * Call all event hooks for a given event\n   */\n  _callEventHooks(eventName, payload) {\n    if (this.eventHooks[eventName]) {\n      for (const fn of this.eventHooks[eventName]) {\n        try { fn(payload, this); } catch (e) { if (this.debug) console.error('[AIController] Event hook error:', e); }\n      }\n    }\n  }\n\n  update(delta, context = {}) {\n    if (!this.active) return;\n    this.lastDecision += delta;\n    if (this.lastDecision < this.decisionInterval) return;\n    this.lastDecision = 0;\n    // Merge context with options.context if provided\n    const mergedContext = { ...context, ...(this.options.context || {}) };\n    // Plugins can modify state or context before behavior\n    for (const plugin of this.plugins) {\n      try { plugin.onUpdate?.(this, delta, mergedContext); } catch (e) { if (this.debug) console.error('[AIController] Plugin update error:', e); }\n    }\n    const behaviorFn = getBehaviorFnFromRegistries(this.behavior);\n    if (typeof behaviorFn === 'function') {\n      try {\n        behaviorFn(this.entity, this.state, mergedContext, this.options);\n      } catch (err) {\n        if (this.debug) console.error('[AIController] Behavior error:', err);\n        eventManager?.dispatchEvent('aiError', { ai: this, error: err });\n      }\n    }\n  }\n\n  setBehavior(behavior) {\n    if (getBehaviorFnFromRegistries(behavior)) {\n      this.behavior = behavior;\n      eventManager?.dispatchEvent('aiBehaviorChanged', { ai: this, behavior });\n    }\n  }\n\n  stop() { this.active = false; }\n  start() { this.active = true; }\n\n  /**\n   * Broadcast a custom event to this AIController (plugins and hooks)\n   */\n  onEvent(eventName, payload) {\n    for (const plugin of this.plugins) {\n      try { plugin.onEvent?.(this, eventName, payload); } catch (e) { if (this.debug) console.error('[AIController] Plugin event error:', e); }\n    }\n    this._callEventHooks(eventName, payload);\n  }\n\n  /**\n   * Debug/diagnostic emitter for AIController\n   */\n  _emitDebug(event, data) {\n    logDiagnostic(event, { ai: this, ...data });\n    eventManager?.dispatchEvent('aiDebug', { event, ai: this, ...data });\n  }\n}\n\n/**\n * Refactored AI behaviors to reduce cognitive complexity\n */\nfunction findNearestEntity(entity, entities) {\n  let nearest = null, minDist = Infinity;\n  for (const e of entities) {\n    if (e === entity) continue;\n    const d = Math.hypot(e.x - entity.x, e.y - entity.y);\n    if (d < minDist) { minDist = d; nearest = e; }\n  }\n  return { nearest, minDist };\n}\n\nfunction shouldJumpOverObstacle(entity, obstacles) {\n  for (const obs of obstacles) {\n    if (Math.abs(obs.x - entity.x) < 40 && Math.abs(obs.y - entity.y) < 30) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findNearestPowerup(entity, powerups) {\n  let nearestPU = null, minDistPU = Infinity;\n  for (const pu of powerups) {\n    const d = Math.hypot(pu.x - entity.x, pu.y - entity.y);\n    if (d < minDistPU) { minDistPU = d; nearestPU = pu; }\n  }\n  return { nearestPU, minDistPU };\n}\n\nregisterAIBehavior('basic', (entity, state, context, options) => {\n  const { players = [], obstacles = [], powerups = [] } = context;\n  if (!entity || !players.length) return;\n  const { nearest, minDist } = findNearestEntity(entity, players);\n  if (!nearest) return;\n  if (nearest.x < entity.x) entity.moveLeft?.();\n  else if (nearest.x > entity.x) entity.moveRight?.();\n  if (shouldJumpOverObstacle(entity, obstacles)) entity.jump?.();\n  for (const pu of powerups) {\n    if (Math.hypot(pu.x - entity.x, pu.y - entity.y) < 30) {\n      entity.moveToward?.(pu.x, pu.y);\n    }\n  }\n  if (minDist < 40) entity.attack?.();\n});\n\nregisterAIBehavior('aggressive', (entity, state, context, options) => {\n  const { players = [] } = context;\n  if (!entity || !players.length) return;\n  const { nearest, minDist } = findNearestEntity(entity, players);\n  if (!nearest) return;\n  if (nearest.x < entity.x) entity.moveLeft?.();\n  else if (nearest.x > entity.x) entity.moveRight?.();\n  if (minDist < 60) entity.attack?.();\n});\n\nregisterAIBehavior('defensive', (entity, state, context, options) => {\n  const { players = [], obstacles = [], powerups = [] } = context;\n  if (!entity) return;\n  const { nearest, minDist } = findNearestEntity(entity, players);\n  if (nearest && minDist < 80) {\n    if (nearest.x < entity.x) entity.moveRight?.();\n    else entity.moveLeft?.();\n  }\n  const { nearestPU } = findNearestPowerup(entity, powerups);\n  if (nearestPU) entity.moveToward?.(nearestPU.x, nearestPU.y);\n  if (shouldJumpOverObstacle(entity, obstacles)) entity.jump?.();\n});\n\n/**\n * AI diagnostics and utilities\n */\nexport const aiDiagnostics = {\n  getBehaviors: () => Object.keys(AI_BEHAVIORS),\n  getBehaviorFn: (name) => AI_BEHAVIORS[name],\n};\n\n// Register AI system in the shared game context for global access and analytics\nregisterSystem('aiControllers', gameContext.aiControllers);\n\n// --- Integration: register AI systems in context\nregisterSystem('AIController', AIController);\nregisterSystem('AI_BEHAVIORS', AI_BEHAVIORS);\n\n// Listen for global game events to allow AI to react to cross-system events\nif (eventManager && typeof eventManager.subscribe === 'function') {\n  eventManager.subscribe('powerupCollected', ({ player, powerup }) => {\n    for (const ai of gameContext.aiControllers) {\n      ai.onEvent('powerupCollected', { player, powerup });\n    }\n    logDiagnostic('aiPowerupReact', { player, powerup });\n  });\n  eventManager.subscribe('obstacleSpawned', ({ obstacle }) => {\n    for (const ai of gameContext.aiControllers) {\n      ai.onEvent('obstacleSpawned', { obstacle });\n    }\n    logDiagnostic('aiObstacleReact', { obstacle });\n  });\n  eventManager.subscribe('playerHit', ({ attacker, defender, damage }) => {\n    for (const ai of gameContext.aiControllers) {\n      ai.onEvent('playerHit', { attacker, defender, damage });\n    }\n    logDiagnostic('aiPlayerHitReact', { attacker, defender, damage });\n  });\n  // Add more event hooks as needed for advanced integration\n}\n\n// --- Integration: update all AIControllers in game loop ---\nexport const aiControllers = [];\nexport function addAIController(ai) {\n  aiControllers.push(ai);\n  eventManager?.dispatchEvent('aiControllerAdded', { ai });\n}\nexport function removeAIController(ai) {\n  const idx = aiControllers.indexOf(ai);\n  if (idx !== -1) {\n    aiControllers.splice(idx, 1);\n    eventManager?.dispatchEvent('aiControllerRemoved', { ai });\n  }\n}\nexport function updateAllAIControllers(delta, context) {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  for (const ai of aiControllers) ai.update(delta, context);\n}\n\n// --- Utility and Robust Features for AI System ---\n\n/**\n * Get all active AIControllers\n */\nexport function getActiveAIControllers() {\n  // Use shared context array to ensure controllers are tracked\n  return gameContext.aiControllers.filter(ai => ai.active);\n}\n\n/**\n * Get AIControllers by behavior\n * @param {string} behavior\n */\nexport function getAIControllersByBehavior(behavior) {\n  return aiControllers.filter(ai => ai.behavior === behavior);\n}\n\n/**\n * Pause/resume all AIControllers (for game pause)\n */\nlet _aiPaused = false;\nexport function pauseAllAI() {\n  if (_aiPaused) return;\n  for (const ai of aiControllers) ai.stop();\n  _aiPaused = true;\n}\nexport function resumeAllAI() {\n  if (!_aiPaused) return;\n  for (const ai of aiControllers) ai.start();\n  _aiPaused = false;\n}\nexport function isAIPaused() {\n  return _aiPaused;\n}\n\n/**\n * Remove all inactive AIControllers (manual cleanup)\n */\nexport function removeInactiveAIControllers() {\n  for (let i = aiControllers.length - 1; i >= 0; i--) {\n    if (!aiControllers[i].active) aiControllers.splice(i, 1);\n  }\n}\n\n/**\n * Export/import AIControllers for save/load or replay\n * Only serializes minimal info (entity id, behavior, options, state)\n */\nexport function exportAIControllers() {\n  return aiControllers.map(ai => ({\n    entityId: ai.entity?.id,\n    behavior: ai.behavior,\n    options: { ...ai.options },\n    state: { ...ai.state },\n    active: ai.active\n  }));\n}\nexport function importAIControllers(arr, entityResolver) {\n  // entityResolver: function(id) => entity instance\n  aiControllers.length = 0;\n  for (const data of arr) {\n    const entity = entityResolver?.(data.entityId);\n    if (entity) {\n      const ai = new AIController(entity, data.behavior, data.options);\n      ai.state = data.state;\n      ai.active = data.active;\n      aiControllers.push(ai);\n    }\n  }\n}","/**\n * powerups.js - Advanced, extensible power-up system for Stick Fighter\n * Author: Modularized & enhanced from original monolithic code, further expanded for modern ES module architecture\n */\n\nimport { eventManager } from './eventManager.js';\nimport { getScreenState } from '../ui/screenManager.js';\n\n/**\n * Power-up type registry for dynamic registration and extensibility\n */\nexport const POWERUP_TYPES = Object.create(null);\n\n/**\n * Register a new power-up type\n * @param {string} type\n * @param {object} config { color, effect, description, rarity, stackable, icon, sound, ... }\n */\nexport function registerPowerUpType(type, config) {\n  if (!type || typeof config !== 'object') throw new Error('registerPowerUpType: Invalid arguments');\n  POWERUP_TYPES[type] = { ...config };\n  eventManager?.dispatchEvent('powerupTypeRegistered', { type, config });\n}\n\n/**\n * Unregister a power-up type\n * @param {string} type\n */\nexport function unregisterPowerUpType(type) {\n  if (POWERUP_TYPES[type]) {\n    delete POWERUP_TYPES[type];\n    eventManager?.dispatchEvent('powerupTypeUnregistered', { type });\n  }\n}\n\n// --- Default power-up types ---\nregisterPowerUpType('health', {\n  color: '#4CAF50',\n  effect: (player, opts = {}) => { player.health = Math.min(player.health + (opts.amount || 20), player.maxHealth || 100); },\n  description: 'Restores health.',\n  rarity: 1,\n  stackable: false,\n  icon: 'plus',\n});\nregisterPowerUpType('speed', {\n  color: '#2196F3',\n  effect: (player, opts = {}) => { player.addStatusEffect?.('speed', opts.duration || 5000); },\n  description: 'Increases speed temporarily.',\n  rarity: 2,\n  stackable: true,\n  icon: 'arrow',\n});\nregisterPowerUpType('shield', {\n  color: '#FFC107',\n  effect: (player, opts = {}) => { player.addStatusEffect?.('shield', opts.duration || 4000); },\n  description: 'Temporary shield.',\n  rarity: 2,\n  stackable: false,\n  icon: 'shield',\n});\nregisterPowerUpType('invincibility', {\n  color: '#E91E63',\n  effect: (player, opts = {}) => { player.addStatusEffect?.('invincible', opts.duration || 3000); },\n  description: 'Become invincible for a short time.',\n  rarity: 5,\n  stackable: false,\n  icon: 'star',\n});\nregisterPowerUpType('doubleDamage', {\n  color: '#9C27B0',\n  effect: (player, opts = {}) => { player.addStatusEffect?.('doubleDamage', opts.duration || 4000); },\n  description: 'Double attack damage.',\n  rarity: 3,\n  stackable: true,\n  icon: 'sword',\n});\nregisterPowerUpType('areaHeal', {\n  color: '#00BCD4',\n  effect: (player, opts = {}) => { if (opts.allPlayers) opts.allPlayers.forEach(p => p.health = Math.min(p.health + (opts.amount || 10), p.maxHealth || 100)); },\n  description: 'Heals all players nearby.',\n  rarity: 4,\n  stackable: false,\n  icon: 'heart',\n});\n\n/**\n * Power-up state machine\n */\nexport const PowerUpState = Object.freeze({\n  IDLE: 'idle',\n  FALLING: 'falling',\n  COLLECTED: 'collected',\n  EXPIRED: 'expired',\n});\n\n/**\n * PowerUp class with advanced features\n */\nexport class PowerUp {\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {number} radius\n   * @param {string} type\n   * @param {object} options\n   */\n  constructor(x, y, radius, type = 'health', options = {}) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.type = type;\n    this.options = { ...options };\n    const def = POWERUP_TYPES[type] || {};\n    this.color = options.color || def.color || '#FFF';\n    this.icon = options.icon || def.icon || null;\n    this.active = true;\n    this.spawnTime = Date.now();\n    this.id = options.id || `powerup_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;\n    this.effect = options.effect || def.effect;\n    this.description = options.description || def.description || '';\n    this.fallSpeed = options.fallSpeed || 2.5;\n    this.lifetime = options.lifetime || 15000;\n    this.debug = options.debug || false;\n    this.rarity = options.rarity || def.rarity || 1;\n    this.stackable = options.stackable ?? def.stackable ?? false;\n    this.state = PowerUpState.FALLING;\n    this.collectedBy = null;\n    this.expired = false;\n    this.visual = options.visual || null; // custom draw/animation\n    this.sound = options.sound || def.sound || null;\n    this.meta = { ...(def.meta || {}), ...(options.meta || {}) };\n  }\n\n  draw(ctx) {\n    if (!ctx) throw new Error('PowerUp.draw: ctx is required');\n    ctx.save();\n    ctx.globalAlpha = this.active ? 1 : 0.5;\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#FFF';\n    ctx.lineWidth = 2;\n    // Icon or type-specific drawing\n    if (typeof this.visual === 'function') {\n      this.visual(ctx, this);\n    } else if (this.icon === 'plus' || this.type === 'health') {\n      ctx.beginPath();\n      ctx.moveTo(this.x - this.radius / 2, this.y);\n      ctx.lineTo(this.x + this.radius / 2, this.y);\n      ctx.moveTo(this.x, this.y - this.radius / 2);\n      ctx.lineTo(this.x, this.y + this.radius / 2);\n      ctx.stroke();\n    } else if (this.icon === 'arrow' || this.type === 'speed') {\n      ctx.beginPath();\n      ctx.moveTo(this.x - this.radius / 3, this.y);\n      ctx.lineTo(this.x + this.radius / 3, this.y);\n      ctx.stroke();\n    } else if (this.icon === 'shield' || this.type === 'shield') {\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.radius * 0.6, Math.PI, 2 * Math.PI);\n      ctx.lineTo(this.x + this.radius * 0.6, this.y);\n      ctx.stroke();\n    } else if (this.icon === 'star' || this.type === 'invincibility') {\n      // Draw a simple star\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      ctx.rotate(Math.PI / 10);\n      ctx.beginPath();\n      for (let i = 0; i < 5; i++) {\n        ctx.lineTo(0, -this.radius * 0.7);\n        ctx.rotate(Math.PI / 5);\n        ctx.lineTo(0, -this.radius * 0.3);\n        ctx.rotate(Math.PI / 5);\n      }\n      ctx.closePath();\n      ctx.stroke();\n      ctx.restore();\n    }\n    ctx.restore();\n  }\n\n  update(delta, canvasHeight) {\n    if (!this.active || this.state !== PowerUpState.FALLING) return;\n    this.y += this.fallSpeed * (delta / (1000 / 60));\n    if (this.y - this.radius > canvasHeight) {\n      this.active = false;\n      this.state = PowerUpState.EXPIRED;\n      this.expired = true;\n      eventManager?.dispatchEvent('powerupExpired', { powerup: this });\n    }\n    if (Date.now() - this.spawnTime > this.lifetime) {\n      this.active = false;\n      this.state = PowerUpState.EXPIRED;\n      this.expired = true;\n      eventManager?.dispatchEvent('powerupExpired', { powerup: this });\n    }\n  }\n\n  apply(player, opts = {}) {\n    if (!this.active || this.state !== PowerUpState.FALLING) return;\n    try {\n      this.effect?.(player, opts);\n      this.active = false;\n      this.state = PowerUpState.COLLECTED;\n      this.collectedBy = player;\n      if (this.sound) this.playSound();\n      eventManager?.dispatchEvent('powerupCollected', { powerup: this, player });\n    } catch (err) {\n      eventManager?.dispatchEvent('powerupError', { powerup: this, error: err });\n      if (this.debug) console.error(`[PowerUp] Error applying effect:`, err);\n    }\n  }\n\n  playSound() {\n    if (typeof this.sound === 'function') {\n      this.sound();\n    } else if (typeof window !== 'undefined' && this.sound) {\n      const audio = new window.Audio(this.sound);\n      audio.play();\n    }\n  }\n\n  serialize() {\n    return {\n      id: this.id,\n      type: this.type,\n      x: this.x,\n      y: this.y,\n      radius: this.radius,\n      color: this.color,\n      icon: this.icon,\n      active: this.active,\n      state: this.state,\n      description: this.description,\n      options: { ...this.options },\n      debug: this.debug,\n      rarity: this.rarity,\n      stackable: this.stackable,\n      meta: { ...this.meta },\n    };\n  }\n\n  static deserialize(data) {\n    return new PowerUp(data.x, data.y, data.radius, data.type, data.options);\n  }\n\n  describe() {\n    return this.serialize();\n  }\n}\n\n/**\n * Power-up array and management\n */\nexport const powerUps = [];\n\nexport function addPowerUp(powerup) {\n  if (!(powerup instanceof PowerUp)) throw new TypeError('addPowerUp: argument must be a PowerUp');\n  powerUps.push(powerup);\n  eventManager?.dispatchEvent('powerupAdded', { powerup });\n}\n\nexport function removePowerUpById(id) {\n  const idx = powerUps.findIndex(p => p.id === id);\n  if (idx !== -1) {\n    const [removed] = powerUps.splice(idx, 1);\n    eventManager?.dispatchEvent('powerupRemoved', { powerup: removed });\n    return removed;\n  }\n  return null;\n}\n\nexport function clearPowerUps() {\n  powerUps.length = 0;\n  eventManager?.dispatchEvent('powerupsCleared');\n}\n\nexport function updatePowerUps(delta, canvasHeight) {\n  for (const pu of powerUps) pu.update(delta, canvasHeight);\n}\n\nexport function updateAllPowerUps(delta, context) {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  updatePowerUps(delta, context?.canvasHeight || 400);\n}\n\nexport function drawAllPowerUps(ctx) {\n  for (const pu of powerUps) pu.draw(ctx);\n}\n\nexport function getPowerUpAtPoint(x, y) {\n  return powerUps.find(pu => pu.active && Math.hypot(pu.x - x, pu.y - y) <= pu.radius) || null;\n}\n\nexport function getActivePowerUps() {\n  return powerUps.filter(pu => pu.active);\n}\n\nexport function describeAllPowerUps() {\n  return powerUps.map(pu => pu.describe());\n}\n\nexport function getPowerUpsByType(type) {\n  return powerUps.filter(pu => pu.type === type);\n}\n\nexport function getPowerUpsByState(state) {\n  return powerUps.filter(pu => pu.state === state);\n}\n\nexport function spawnRandomPowerUp(x, y, radius = 16, options = {}) {\n  // Weighted random by rarity\n  const types = Object.entries(POWERUP_TYPES);\n  const totalWeight = types.reduce((sum, [k, v]) => sum + (v.rarity || 1), 0);\n  let r = Math.random() * totalWeight;\n  for (const [type, def] of types) {\n    r -= def.rarity || 1;\n    if (r <= 0) {\n      const pu = new PowerUp(x, y, radius, type, options);\n      addPowerUp(pu);\n      eventManager?.dispatchEvent('powerupSpawned', { powerup: pu });\n      return pu;\n    }\n  }\n  // fallback\n  const pu = new PowerUp(x, y, radius, 'health', options);\n  addPowerUp(pu);\n  eventManager?.dispatchEvent('powerupSpawned', { powerup: pu });\n  return pu;\n}\n\nexport function serializeAllPowerUps() {\n  return powerUps.map(pu => pu.serialize());\n}\n\nexport function loadPowerUpsFromData(arr) {\n  clearPowerUps();\n  for (const data of arr) {\n    addPowerUp(PowerUp.deserialize(data));\n  }\n}\n\n// --- EventManager integration for diagnostics and analytics ---\neventManager?.subscribe?.('powerupAdded', ({ powerup }) => {\n  if (getScreenState && getScreenState() !== 'PLAYING') return;\n  // ...diagnostic code...\n});\n\neventManager?.subscribe?.('screenStateChanged', ({ state }) => {\n  if (window?.DEBUG_MODE) {\n    console.debug(`[PowerUps] Screen state changed to: ${state}`);\n  }\n  // Optionally: pause/resume powerup timers, analytics, etc.\n});","// bootstrap.js - Centralized wiring for Stick Fighter\r\nimport { preloadAssets } from './game/preloader.js';\r\nimport { setupResponsiveCanvas } from './game/canvasManager.js';\r\nimport { loadGameState } from './game/saveManager.js';\r\nimport { eventManager } from './game/eventManager.js';\r\nimport gameContext, { setMenuState, registerSystem, broadcastGameEvent, logDiagnostic } from './game/gameContext.js';\r\nimport { initControls, onControlsChanged } from './game/controls.js';\r\nimport obstaclesMod from './game/obstacles.js';\r\nimport * as stickmanMod from './game/stickman.js';\r\nimport * as aiMod from './game/ai.js';\r\nimport * as powerupsMod from './game/powerups.js';\r\n\r\nwindow.eventManager    = eventManager;\r\nwindow.gameContext     = gameContext;\r\nwindow.setMenuState    = setMenuState;\r\nwindow.registerSystem  = registerSystem;\r\nwindow.broadcastGameEvent = broadcastGameEvent;\r\nwindow.logDiagnostic   = logDiagnostic;\r\n\r\n// Preload assets and then start the game\r\nconst loadingEl = document.createElement('div');\r\nloadingEl.id = 'loadingOverlay';\r\nloadingEl.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-75 text-white text-lg z-50';\r\nloadingEl.innerText = 'Loading… 0%';\r\ndocument.body.appendChild(loadingEl);\r\n\r\npreloadAssets((loaded, total) => {\r\n  loadingEl.innerText = `Loading… ${Math.floor((loaded/total)*100)}%`;\r\n})\r\n  .then(assets => {\r\n    window.gameAssets = Object.fromEntries(assets.map(a => [a.key, a.data]));\r\n    document.body.removeChild(loadingEl);\r\n    // Responsive canvas\r\n    setupResponsiveCanvas('gameCanvas', 800, 400);\r\n    // Restore game state if available\r\n    const saved = loadGameState();\r\n    if (saved) {\r\n      window.eventManager?.dispatchEvent('restoreGame', saved);\r\n    }\r\n    // Wire controls\r\n    initControls();\r\n    // Expose submodules\r\n    window.stickman  = stickmanMod;\r\n    window.controls  = { initControls, onControlsChanged };\r\n    window.ai        = aiMod;\r\n    window.obstacles = obstaclesMod;\r\n    window.powerups  = powerupsMod;\r\n    // Fire “app ready” so UI can show an initial message\r\n    window.dispatchEvent(new Event('stickFighterAppReady'));\r\n    // Dynamically import main entrypoint\r\n    import('./index.js');\r\n  })\r\n  .catch(err => {\r\n    console.error('Asset preload failed:', err);\r\n    loadingEl.innerText = 'Failed to load resources. Check console.';\r\n  });\r\n","// canvasManager.js - Responsive canvas setup for Stick Fighter\r\n// Usage: import { setupResponsiveCanvas } from './canvasManager.js';\r\n\r\nexport function setupResponsiveCanvas(canvasId, baseWidth = 800, baseHeight = 400) {\r\n  const canvas = document.getElementById(canvasId);\r\n  if (!canvas) throw new Error(`Canvas with ID ${canvasId} not found.`);\r\n  function resize() {\r\n    // Calculate integer scale to maintain pixel fidelity\r\n    const scale = Math.max(\r\n      Math.floor(window.innerWidth / baseWidth),\r\n      Math.floor(window.innerHeight / baseHeight)\r\n    ) || 1;\r\n    canvas.style.width  = `${baseWidth * scale}px`;\r\n    canvas.style.height = `${baseHeight * scale}px`;\r\n    // Keep internal resolution constant\r\n    canvas.width  = baseWidth;\r\n    canvas.height = baseHeight;\r\n  }\r\n  window.addEventListener('resize', resize);\r\n  resize();\r\n}\r\n"],"names":["assetManifest","key","type","path","SAVE_KEY","saveGameState","stateObj","text","JSON","stringify","localStorage","setItem","e","console","error","loadGameState","raw","getItem","parsed","parse","players","Array","isArray","Error","warn","removeItem","eventManager","constructor","this","listeners","eventLog","debugMode","subscribe","eventType","callback","push","_log","_logError","unsubscribe","filter","listener","dispatchEvent","detail","timestamp","Date","now","forEach","message","once","wrapper","getEventLog","clearEventLog","enableDebug","disableDebug","msg","data","undefined","log","gameContext","aiControllers","obstacles","powerups","hitSparks","diagnostics","menuState","registerSystem","name","ref","logDiagnostic","event","SCREEN_STATES","MENU","SETTINGS","PAUSED","PLAYING","END","currentScreen","getScreenState","setScreenState","state","Object","values","includes","fn","onScreenStateChange","updateScreenOverlays","pauseMenu","document","getElementById","settingsMenu","canvas","style","display","Obstacle","x","y","width","height","color","options","TypeError","id","Math","random","toString","slice","debug","retryCount","maxRetries","err","handleError","draw","ctx","attempts","save","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","setLineDash","restore","getAABB","containsPoint","px","py","overlaps","rect","rectsOverlap","setColor","move","dx","dy","clone","describe","area","aspectRatio","isWide","isTall","isSquare","abs","top","bottom","left","right","center","canClimb","canDestroy","canJumpOver","method","errorLog","errorMsg","time","obstacle","obstacleDestroyedListeners","onObstacleDestroyed","clearObstacles","length","checkObstacleCollision","r1","r2","drawAllObstacles","setObstacles","newObstacles","o","updateAllObstacles","delta","context","getContext","obstaclesMod","addObstacle","removeObstacleById","idx","findIndex","removed","splice","cb","getObstacleAtPoint","find","getObstaclesInRect","getObstacleById","setObstaclesDebug","serializeObstacles","map","loadObstaclesFromArray","arr","obj","describeAllObstacles","keyState","keyMap","defaultBindings","freeze","player1","jump","punch","kick","guard","slam","airDodge","parry","run","turn","player2","getKeyBindings","debugHooks","onInput","onRemap","onRecording","onPlayback","emitDebugEvent","payload","comboState","active","sequence","lastInputTime","comboWindow","minComboLength","maxComboLength","onCombo","clearCombo","_registerComboInput","code","isDown","_checkComboTimeout","shift","player","comboSequence","comboPerformedListeners","window","DEBUG_MODE","fireComboPerformed","onComboPerformed","handleKeyEvent","repeat","shouldDebounceInput","processDebugHooks","notifyListeners","processComboSystem","handleKeyDown","handleKeyUp","resetKeyBindings","bindings","onControlsChanged","initControls","_stickfighterControlsAttached","addEventListener","Track","propertyPath","keyframes","AnimationClip","duration","tracks","loop","AnimationPlayer","currentClip","playing","onFinish","blendActive","blendElapsed","blendDuration","initialPose","latestPose","play","clip","opts","blend","stop","samplePose","pose","track","frames","i","kf","value","a","b","t0","update","poseTo","outPose","blendPose","t","min","blended","fromVal","idleClip","drawBoneCylinder","p1","p2","atan2","lineCap","beginPath","moveTo","lineTo","stroke","HIT_SPARK_TYPES","create","_spriteCache","registerHitSparkType","config","spriteSheet","img","Image","src","particleCount","size","sound","HitSpark","def","spawnTime","meta","impact","comboCount","animSpeed","frameIndex","frameElapsed","character","particles","_createParticles","playSound","hitSpark","baseAngle","angle","baseForce","force","baseVx","vx","baseVy","vy","PI","cos","sin","alpha","p","globalAlpha","frameW","frameH","frameIdx","drawImage","arc","fill","Audio","serialize","deserialize","spawnHitSpark","styleType","_lastSparkTime","COMBO_WINDOW","_comboCount","_trackCombo","sparkType","screenShake","effect","strength","combo","flash","slowMo","soundLayer","audio","volume","hs","updateAllHitSparks","drawAllHitSparks","hitter","sqrt","powerup","Stickman","prototype","spawnHitSparkOnHit","target","attackInfo","characterName","critical","comboInfo","level","cameraShake","screenFlash","defender","stickmanRegistry","registerStickman","instance","getAllStickmen","updateAllStickmen","stickmen","sm","opponent","colors","isPlayer1","controls","isNPC","aiType","prevX","velocityX","velocityY","yBase","facingRight","isRunning","isJumping","mass","aiActionCooldown","aiDecisionIntervalBase","aiPreferredDistance","aiBaseAttackProb","aiBaseGuardProb","aiBaseParryProb","aiBaseJumpProb","aiTargetX","aiWantsToAttack","aiWantsToGuard","aiWantsToParry","aiWantsToJump","isGuarding","isParrying","isDodging","isAttacking","isPerformingSpecialMove","specialMoveType","attackType","attackTimer","groundSlamImpactDone","hitStunTimer","dodgeTimer","dodgeCooldownTimer","parryTimer","parryCooldownTimer","parryFailedVulnTimer","count","lastAttackTime","lastAttackType","health","limbImpairDuration","limbs","leftUpperArm","impairedTimer","leftLowerArm","rightUpperArm","rightLowerArm","leftUpperLeg","leftLowerLeg","rightUpperLeg","rightLowerLeg","limbSegmentLength","walkCycleTime","leftFootPlantedX","rightFootPlantedX","activeProceduralAnimation","currentAngles","defaultAngles","targetAngles","animPlayer","index","indexOf","idleTime","leftShoulderZ","rightShoulderZ","leftElbowZ","rightElbowZ","leftHipZ","rightHipZ","leftKneeZ","rightKneeZ","getJointPositions","hip","neck","leftShoulder","rightShoulder","leftElbow","rightElbow","leftKnee","rightKnee","head","cx","cy","radius","leftHand","rightHand","leftFoot","rightFoot","getLimbColor","limb","getLimbHitboxes","joints","hitboxes","createSegmentAABB","torso","lineJoin","headColor","grad","createRadialGradient","addColorStop","headOutline","GROUND_LEVEL","playAnimation","solveLegIK","targetX","targetY","isLeftLeg","l1","l2","dist","hypot","max","cosAngle","hipAngle","acos","kneeAngle","side","updateTargetAngles","applyProceduralAnimation","baseArmAngle","baseElbowAngle","baseHipAngle","baseKneeAngle","applyWalkingAngles","dir","armSwing","elbowBend","hipSwing","kneeBend","applyIdleAngles","idleArm","idleElbow","gameState","canvasHeight","prop","cycle","groundY","canChangeFacing","canAct","canMove","turnAround","initiateAttack","startTime","startAngles","checkHit","initiateSpecialMove","moveType","GROUND_SLAM_FORCE","initiateParry","PARRY_DURATION","PARRY_COOLDOWN","initiateAirDodge","AIR_DODGE_DURATION","AIR_DODGE_COOLDOWN","AIR_DODGE_FORCE","takeDamage","damage","attacker","gameAssets","hitSound","sfx","cloneNode","currentTime","catch","getHitLimbs","facingTowards","getAttackRange","FLYING_KICK_RANGE","GROUND_SLAM_AOE_RANGE","PUNCH_RANGE","KICK_RANGE","getDamage","FLYING_KICK_DAMAGE","GROUND_SLAM_DAMAGE","PUNCH_DAMAGE","KICK_DAMAGE","getKnockback","multiplier","KNOCKBACK_SPECIAL_MULTIPLIER","KNOCKBACK_BASE_X","KNOCKBACK_BASE_Y","updateComboState","handleParrySuccess","HIT_STUN_DURATION_HEAVY","PARRY_SUCCESS_STUN_MULTIPLIER","PARRY_FAIL_VULNERABLE_DURATION","handleGroundSlamImpact","aiDecideAction","distance","aiExecuteAction","maxSpeed","direction","BASE_PLAYER_ACCELERATION","JUMP_FORCE","stickman","stickRect","range","probeRect","obs","AI_BEHAVIORS","_behaviorRegistries","getBehaviorFnFromRegistries","reg","registerAIBehavior","behaviorFn","AIController","entity","behavior","lastDecision","decisionInterval","plugins","eventHooks","addAIController","ai","attachPlugin","plugin","onAttach","detachPlugin","onDetach","addEventHook","eventName","removeEventHook","_callEventHooks","mergedContext","onUpdate","setBehavior","start","onEvent","_emitDebug","findNearestEntity","entities","nearest","minDist","Infinity","d","shouldJumpOverObstacle","moveLeft","moveRight","pu","moveToward","attack","nearestPU","minDistPU","findNearestPowerup","aiDiagnostics","getBehaviors","keys","getBehaviorFn","updateAllAIControllers","_aiPaused","registry","entityId","entityResolver","POWERUP_TYPES","registerPowerUpType","amount","maxHealth","description","rarity","stackable","icon","addStatusEffect","allPlayers","PowerUpState","IDLE","FALLING","COLLECTED","EXPIRED","PowerUp","fallSpeed","lifetime","collectedBy","expired","visual","translate","rotate","closePath","apply","powerUps","addPowerUp","clearPowerUps","updatePowerUps","updateAllPowerUps","drawAllPowerUps","types","entries","totalWeight","reduce","sum","k","v","r","setMenuState","broadcastGameEvent","loadingEl","createElement","className","innerText","body","appendChild","onProgress","promises","asset","Promise","resolve","reject","onload","onerror","oncanplaythrough","fetch","then","res","json","result","all","preloadAssets","loaded","total","floor","assets","fromEntries","removeChild","canvasId","baseWidth","baseHeight","resize","scale","innerWidth","innerHeight","setupResponsiveCanvas","saved","stickmanMod","aiMod","powerupsMod","Event","import"],"mappings":"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"}
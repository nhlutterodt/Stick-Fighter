<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Procedural World Generator</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #controls-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(40, 40, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
            width: 320px; /* Slightly wider for new controls */
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-group:last-child {
            border-bottom: none;
        }
        h3 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }
        input[type="range"], input[type="number"], select {
            width: calc(100% - 20px);
            padding: 8px 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #e0e0e0;
            box-sizing: border-box;
        }
        input[type="range"] {
            padding: 0; /* Override for range inputs */
        }
        button {
            background-color: #61dafb;
            color: #1a1a1a;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
            width: 100%;
            margin-top: 10px;
            box-sizing: border-box;
        }
        button:hover {
            background-color: #82eaff;
        }
        button.secondary { 
            background-color: #4CAF50; 
            color: white;
        }
        button.secondary:hover {
            background-color: #66bb6a;
        }
        .paint-type-button {
            width: calc(50% - 5px); /* Two buttons per row */
            margin-bottom: 5px;
            background-color: #555;
            color: #e0e0e0;
        }
        .paint-type-button.active {
            background-color: #61dafb;
            color: #1a1a1a;
            border: 2px solid #fff;
        }
        .button-row {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.8em;
        }
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #fff;
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 8px;
            display: none; /* Hidden by default */
            z-index: 100;
        }
        canvas { display: block; cursor: crosshair; } /* Change cursor for painting */
        /* Style for the custom error message */
        .critical-error-message { 
            position:fixed; 
            bottom:20px; 
            left:50%; 
            transform:translateX(-50%); 
            background-color:rgba(220,53,69,0.9); 
            color:white; 
            padding:10px 15px; 
            border-radius:5px; 
            z-index:10000; 
            font-size: 0.9em; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
            text-align:center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="controls-container">
        <div class="control-group">
            <h3>Terrain Dimensions</h3>
            <label for="terrainWidth">Width (units): <span id="terrainWidthVal">200</span></label>
            <input type="range" id="terrainWidth" min="50" max="500" value="200" step="10">
            
            <label for="terrainDepth">Depth (units): <span id="terrainDepthVal">200</span></label>
            <input type="range" id="terrainDepth" min="50" max="500" value="200" step="10">

            <label for="segments">Segments (complexity): <span id="segmentsVal">100</span></label>
            <input type="range" id="segments" min="20" max="250" value="100" step="5">
        </div>

        <div class="control-group">
            <h3>Noise Parameters</h3>
            <label for="noiseScale">Noise Scale: <span id="noiseScaleVal">70</span></label>
            <input type="range" id="noiseScale" min="10" max="200" value="70" step="1">
            
            <label for="terrainHeightScale">Max Height: <span id="terrainHeightScaleVal">30</span></label>
            <input type="range" id="terrainHeightScale" min="5" max="100" value="30" step="1">

            <label for="octaves">Octaves (detail): <span id="octavesVal">4</span></label>
            <input type="range" id="octaves" min="1" max="8" value="4" step="1">

            <label for="persistence">Persistence (amplitude): <span id="persistenceVal">0.5</span></label>
            <input type="range" id="persistence" min="0.1" max="1" value="0.5" step="0.05">

            <label for="lacunarity">Lacunarity (frequency): <span id="lacunarityVal">2.0</span></label>
            <input type="range" id="lacunarity" min="1.5" max="4" value="2.0" step="0.1">
        </div>

        <div class="control-group">
            <h3>Terrain Features</h3>
            <label for="plateauLevel">Plateau Level (0-1, 0=off): <span id="plateauLevelVal">0.0</span></label>
            <input type="range" id="plateauLevel" min="0" max="1" value="0.0" step="0.05">
            
            <label for="plateauSmoothing">Plateau Smoothing: <span id="plateauSmoothingVal">0.1</span></label>
            <input type="range"id="plateauSmoothing" min="0.01" max="0.5" value="0.1" step="0.01">

            <label for="valleyDepthFactor">Valley Depth Factor: <span id="valleyDepthFactorVal">1.5</span></label>
            <input type="range" id="valleyDepthFactor" min="1.0" max="5.0" value="1.5" step="0.1">
            
            <label for="valleyThreshold">Valley Threshold (-1 to 0): <span id="valleyThresholdVal">-0.2</span></label>
            <input type="range" id="valleyThreshold" min="-1" max="0" value="-0.2" step="0.05">
        </div>
        
        <div class="control-group">
            <h3>Coloring &amp; Base Types</h3>
            <label for="waterLevel">Water Level (-50 to 50): <span id="waterLevelVal">0</span></label>
            <input type="range" id="waterLevel" min="-50" max="50" value="0" step="1">
        </div>

        <div class="control-group">
            <h3>Terrain Painting</h3>
            <label for="brushSize">Brush Size: <span id="brushSizeVal">10</span></label>
            <input type="range" id="brushSize" min="1" max="50" value="10" step="1">
            <div class="button-row">
                <button class="paint-type-button" data-type="GRASS">Grass</button>
                <button class="paint-type-button" data-type="SAND">Sand</button>
            </div>
            <div class="button-row">
                 <button class="paint-type-button" data-type="ROCK">Rock</button>
                 <button class="paint-type-button" data-type="SNOW">Snow</button>
            </div>
             <div class="button-row">
                <button class="paint-type-button" data-type="LAVA">Lava</button>
                <button class="paint-type-button" data-type="GRAVEL">Gravel</button>
            </div>
        </div>


        <button id="regenerateButton">Regenerate Terrain</button>
        <button id="saveTerrainButton" class="secondary">Save Terrain Data</button>
    </div>

    <div id="loading-indicator">Generating Terrain...</div>
    <div id="info">Use mouse to orbit, scroll to zoom, right-click to pan. Left-click to paint (when a type is selected).</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>console.log('Diag three.js (jsdelivr 0.132.2): typeof window.THREE =', typeof window.THREE);</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>console.log('Diag simplex-noise (2.4.0): typeof window.SimplexNoise =', typeof window.SimplexNoise);</script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>console.log('Diag OrbitControls (jsdelivr for 0.132.2): typeof window.THREE =', typeof window.THREE, '; typeof window.THREE?.OrbitControls =', typeof window.THREE?.OrbitControls);</script>

    <script> 
        // --- Global Variables (declare here, instantiate in init) ---
        let scene, camera, renderer, controls;
        let terrainMesh, waterMesh;
        let simplex; 
        let vertexTerrainTypes = []; // Stores terrain type ID for each vertex
        
        const loadingIndicator = document.getElementById('loading-indicator');
        let animationFrameCount = 0; 

        // --- Terrain Types Definition ---
        const TERRAIN_TYPES = {
            SAND: 0,
            GRASS: 1,
            ROCK: 2,
            SNOW: 3,
            LAVA: 4,
            GRAVEL: 5
        };

        const TERRAIN_COLORS = {
            [TERRAIN_TYPES.SAND]:   new THREE.Color(0xC2B280),
            [TERRAIN_TYPES.GRASS]:  new THREE.Color(0x559955),
            [TERRAIN_TYPES.ROCK]:   new THREE.Color(0x888888),
            [TERRAIN_TYPES.SNOW]:   new THREE.Color(0xFFFFFF),
            [TERRAIN_TYPES.LAVA]:   new THREE.Color(0xFF4500), // OrangeRed
            [TERRAIN_TYPES.GRAVEL]: new THREE.Color(0xA9A9A9)  // DarkGray
        };
        
        let currentBrushType = TERRAIN_TYPES.GRASS; // Default paint type
        let brushSize = 10;
        let isPainting = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();


        // --- Configuration Object ---
        const config = {
            terrainWidth: 200,
            terrainDepth: 200,
            segments: 100,
            noiseScale: 70,
            terrainHeightScale: 30,
            octaves: 4,
            persistence: 0.5,
            lacunarity: 2.0,
            plateauLevel: 0.0, 
            plateauSmoothing: 0.1,
            valleyDepthFactor: 1.5,
            valleyThreshold: -0.2, 
            waterLevel: 0,
        };

        // --- UI Element References and Event Listeners ---
        function setupUI() {
            console.log("LOG: setupUI() called.");
            const inputs = [
                'terrainWidth', 'terrainDepth', 'segments', 'noiseScale', 
                'terrainHeightScale', 'octaves', 'persistence', 'lacunarity',
                'plateauLevel', 'plateauSmoothing', 'valleyDepthFactor', 'valleyThreshold', 'waterLevel'
            ];

            inputs.forEach(id => {
                const inputElement = document.getElementById(id);
                const valueElement = document.getElementById(id + 'Val');
                if (inputElement) {
                    inputElement.value = config[id]; 
                    if (valueElement) valueElement.textContent = config[id]; 
                    inputElement.addEventListener('input', (event) => {
                        const oldValue = config[id];
                        config[id] = id === 'segments' || id === 'octaves' ? parseInt(event.target.value) : parseFloat(event.target.value);
                        if (valueElement) valueElement.textContent = event.target.value;
                    });
                }
            });
            
            const regenerateButton = document.getElementById('regenerateButton');
            if (regenerateButton) {
                regenerateButton.addEventListener('click', () => {
                    console.log("LOG: UI Event - 'Regenerate Terrain' button clicked.");
                    if (!simplex || typeof simplex.noise2D !== 'function') { 
                        displayGlobalError("SimplexNoise not properly initialized. Cannot regenerate terrain.", "simplex-runtime-error");
                        return;
                    }
                    showLoading();
                    setTimeout(() => {
                        createOrUpdateTerrain();
                        hideLoading();
                    }, 50); 
                });
            }

            const saveTerrainButton = document.getElementById('saveTerrainButton');
            if (saveTerrainButton) {
                saveTerrainButton.addEventListener('click', () => {
                    console.log("LOG: UI Event - 'Save Terrain Data' button clicked.");
                    saveTerrainData();
                });
            }
            
            // Painting UI
            const brushSizeInput = document.getElementById('brushSize');
            const brushSizeVal = document.getElementById('brushSizeVal');
            if (brushSizeInput && brushSizeVal) {
                brushSizeInput.value = brushSize;
                brushSizeVal.textContent = brushSize;
                brushSizeInput.addEventListener('input', (event) => {
                    brushSize = parseFloat(event.target.value);
                    brushSizeVal.textContent = brushSize;
                    console.log("LOG: Brush size changed to:", brushSize);
                });
            }

            const paintTypeButtons = document.querySelectorAll('.paint-type-button');
            paintTypeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    currentBrushType = TERRAIN_TYPES[button.dataset.type];
                    console.log("LOG: Selected brush type:", button.dataset.type, "(ID:", currentBrushType, ")");
                    paintTypeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
            });
            // Activate default brush button
            document.querySelector(`.paint-type-button[data-type="${Object.keys(TERRAIN_TYPES).find(key => TERRAIN_TYPES[key] === currentBrushType)}"]`)?.classList.add('active');


            console.log("LOG: setupUI() finished.");
        }
        
        function showLoading() {
            if (loadingIndicator) loadingIndicator.style.display = 'block';
        }

        function hideLoading() {
            if (loadingIndicator) loadingIndicator.style.display = 'none';
        }

        function displayGlobalError(message, id = 'generic-error') {
            const errorDivId = `${id}-message`;
            let errorDiv = document.getElementById(errorDivId);
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = errorDivId;
                errorDiv.className = 'critical-error-message'; 
                document.body.appendChild(errorDiv);
            }
            errorDiv.textContent = message;
            console.error(`ERROR_DISPLAY [${id}]: ${message}`); 
        }

        // --- Initialization ---
        function init() {
            console.log("LOG: init() called via window.onload.");

            try {
                if (typeof window.SimplexNoise === 'function') {
                    simplex = new window.SimplexNoise();
                } else {
                    throw new Error("window.SimplexNoise is not a constructor.");
                }
            } catch (e) {
                displayGlobalError(`CRITICAL: SimplexNoise failed to initialize: ${e.message}.`, "simplex-init-error");
                simplex = { noise2D: () => 0 }; 
            }

            try {
                if (typeof THREE === 'undefined') { 
                    throw new Error("THREE (Three.js main object) is undefined.");
                }
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); 
                scene.fog = new THREE.Fog(0x87CEEB, 100, 600);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(80, 80, 80);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
                
                // Add mouse event listeners for painting to the renderer's DOM element
                renderer.domElement.addEventListener('mousedown', onTerrainMouseDown, false);
                renderer.domElement.addEventListener('mousemove', onTerrainMouseMove, false);
                renderer.domElement.addEventListener('mouseup', onTerrainMouseUp, false);
                // Prevent context menu on right click to allow OrbitControls pan
                renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());


            } catch (e) {
                displayGlobalError(`CRITICAL: Failed to initialize core Three.js objects: ${e.message}.`, "three-core-init-error");
                return; 
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            try {
                if (typeof window.THREE !== 'undefined' && typeof window.THREE.OrbitControls === 'function') {
                    controls = new window.THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.screenSpacePanning = true; // Allow panning with right mouse
                    controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
                } else {
                     throw new Error("THREE.OrbitControls is not a constructor or THREE is undefined.");
                }
            } catch (e) {
                 displayGlobalError(`CRITICAL: THREE.OrbitControls failed to initialize: ${e.message}.`, "orbitcontrols-init-error");
            }

            setupUI(); 
            showLoading();
            setTimeout(() => {
                 createOrUpdateTerrain();
                 hideLoading();
            }, 50);

            window.addEventListener('resize', onWindowResize, false);
            animate();
            console.log("LOG: init() finished successfully.");
        }

        // --- Terrain Generation ---
        function getNoise(x, y, noiseScale, octaves, persistence, lacunarity) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0; 
            for (let i = 0; i < octaves; i++) {
                if (simplex && typeof simplex.noise2D === 'function') {
                    total += simplex.noise2D(x * frequency / noiseScale, y * frequency / noiseScale) * amplitude;
                } else { return 0; }
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= lacunarity;
            }
            return maxValue === 0 ? 0 : total / maxValue; 
        }
        
        function createOrUpdateTerrain() {
            console.log("LOG: createOrUpdateTerrain() called.");
            if (!scene) { 
                console.error("LOG: createOrUpdateTerrain - Scene not initialized. Aborting.");
                return;
            }
            
            if (terrainMesh) {
                scene.remove(terrainMesh);
                terrainMesh.geometry.dispose();
                terrainMesh.material.dispose();
            }
            if (waterMesh) {
                scene.remove(waterMesh);
                waterMesh.geometry.dispose();
                waterMesh.material.dispose();
            }

            const geometry = new THREE.PlaneGeometry( config.terrainWidth, config.terrainDepth, config.segments, config.segments );
            geometry.rotateX(-Math.PI / 2); 

            const positions = geometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);
            vertexTerrainTypes = new Uint8Array(positions.count); // Reset or initialize terrain types

            const tempColor = new THREE.Color(); // For temporary color calculations

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i); 
                let noiseVal = getNoise(x, z, config.noiseScale, config.octaves, config.persistence, config.lacunarity);
                
                if (noiseVal < config.valleyThreshold && Math.abs(config.valleyThreshold) > 1e-5) {
                    const depthFactor = 1 + (config.valleyThreshold - noiseVal) * (config.valleyDepthFactor -1) / Math.abs(config.valleyThreshold);
                    noiseVal *= depthFactor;
                }
                let y = noiseVal * config.terrainHeightScale;

                if (config.plateauLevel > 0) {
                    const heightScaleForNorm = config.terrainHeightScale === 0 ? 1 : config.terrainHeightScale;
                    const normalizedHeight = (y / heightScaleForNorm + 1) / 2; 
                    if (normalizedHeight > config.plateauLevel) {
                        const diff = normalizedHeight - config.plateauLevel;
                        const t = THREE.MathUtils.smoothstep(diff, 0, config.plateauSmoothing); 
                        y = THREE.MathUtils.lerp(y, config.plateauLevel * heightScaleForNorm * 2 - heightScaleForNorm, 1 - t); 
                    }
                }
                positions.setY(i, y);

                // Initial terrain type assignment based on height
                let typeId;
                if (y < config.waterLevel + 2) { 
                    typeId = TERRAIN_TYPES.SAND;
                } else if (y < config.waterLevel + 15) {
                    typeId = TERRAIN_TYPES.GRASS;
                } else if (y < config.terrainHeightScale * 0.6) {
                    typeId = TERRAIN_TYPES.ROCK;
                } else {
                    typeId = TERRAIN_TYPES.SNOW;
                }
                vertexTerrainTypes[i] = typeId;
                
                tempColor.set(TERRAIN_COLORS[typeId]);
                colors[i * 3]     = tempColor.r;
                colors[i * 3 + 1] = tempColor.g;
                colors[i * 3 + 2] = tempColor.b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); 
            geometry.computeVertexNormals(); 

            const material = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.2 });
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.castShadow = true;
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);

            const waterGeometry = new THREE.PlaneGeometry(config.terrainWidth * 1.5, config.terrainDepth * 1.5, 1, 1);
            waterGeometry.rotateX(-Math.PI / 2);
            const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x336699, transparent: true, opacity: 0.7, roughness: 0.1, metalness: 0.3 });
            waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            waterMesh.position.y = config.waterLevel; 
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);
            
            const dirLight = scene.children.find(c => c.type === "DirectionalLight");
            if (dirLight) {
                dirLight.shadow.camera.left = -config.terrainWidth / 1.8; 
                dirLight.shadow.camera.right = config.terrainWidth / 1.8;
                dirLight.shadow.camera.top = config.terrainDepth / 1.8;
                dirLight.shadow.camera.bottom = -config.terrainDepth / 1.8;
                dirLight.shadow.camera.updateProjectionMatrix();
            }
            console.log("LOG: createOrUpdateTerrain() finished.");
        }

        // --- Terrain Painting ---
        function onTerrainMouseDown(event) {
            if (event.button === 0) { // Left mouse button
                isPainting = true;
                if (controls) controls.enabled = false; // Disable camera controls while painting
                paintTerrain(event); // Paint on initial click
                 console.log("LOG: Painting started.");
            }
        }

        function onTerrainMouseMove(event) {
            if (isPainting) {
                paintTerrain(event);
            }
        }

        function onTerrainMouseUp(event) {
            if (event.button === 0) {
                isPainting = false;
                if (controls) controls.enabled = true; // Re-enable camera controls
                console.log("LOG: Painting stopped.");
            }
        }

        function paintTerrain(event) {
            if (!terrainMesh || !camera) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                const intersectionPoint = intersects[0].point;
                const positions = terrainMesh.geometry.attributes.position;
                const colors = terrainMesh.geometry.attributes.color;
                let changed = false;
                const tempVertex = new THREE.Vector3();
                const paintColor = TERRAIN_COLORS[currentBrushType];

                for (let i = 0; i < positions.count; i++) {
                    tempVertex.fromBufferAttribute(positions, i); // Get vertex world position
                    // Note: For a PlaneGeometry rotated flat, this tempVertex is already effectively in world space relative to terrainMesh's origin.
                    // If terrainMesh had transformations, we'd use terrainMesh.localToWorld(tempVertex);
                    
                    const distance = tempVertex.distanceTo(intersectionPoint);

                    if (distance < brushSize) {
                        if (vertexTerrainTypes[i] !== currentBrushType) {
                            vertexTerrainTypes[i] = currentBrushType;
                            colors.setXYZ(i, paintColor.r, paintColor.g, paintColor.b);
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    colors.needsUpdate = true;
                   // console.log("LOG: Terrain painted. Vertices updated.");
                }
            }
        }


        // --- Terrain Saving ---
        function saveTerrainData() {
            console.log("LOG: saveTerrainData() called.");
            if (!terrainMesh || !terrainMesh.geometry) {
                displayGlobalError("No terrain data to save. Please generate terrain first.", "save-terrain-no-data");
                return;
            }
            const geomAttrs = terrainMesh.geometry.attributes;
            if (!geomAttrs.position || !geomAttrs.color || !vertexTerrainTypes || vertexTerrainTypes.length !== geomAttrs.position.count) {
                displayGlobalError("Terrain data is incomplete or corrupted. Cannot save.", "save-terrain-incomplete");
                return;
            }
            
            const terrainData = {
                config: JSON.parse(JSON.stringify(config)),
                geometry: {
                    positions: Array.from(geomAttrs.position.array),
                    // colors: Array.from(geomAttrs.color.array), // Colors are now derived from types
                    terrainTypes: Array.from(vertexTerrainTypes) // Save the type IDs
                }
            };

            try {
                const jsonString = JSON.stringify(terrainData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `terrain_data_painted_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                displayGlobalError("Failed to stringify or save terrain data.", "save-terrain-stringify-error");
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (animationFrameCount === 0 && renderer) { 
                console.log("LOG: animate() - First frame requested.");
            }
            animationFrameCount++;

            if (controls) controls.update(); 
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            if (camera && renderer) { 
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- Start Application ---
        window.onload = () => {
            console.log("Diag: window.onload event fired. Starting application's init().");
            init();
        };
    </script>
</body>
</html>
